{"version":3,"file":"main.js","sources":["../src/parser.js","../src/property.js","../src/declaration.js","../src/rule.js","../src/scope.js","../src/custom-prop.js","../src/store.js","../src/value.js","../src/compute.js","../src/binding.js","../src/constants.js","../src/sparse-array.js","../src/template.js","../src/multi-binding.js","../src/simple-binding.js","../src/bindings.js","../src/each.js","../src/mount.js","../src/render.js","../src/changeset.js","../src/sheet.js","../src/function.js","../src/compile.js"],"sourcesContent":["// @ts-check\n\n/**\n * \n * @typedef {object} WasmParserInterface\n * @property {() => number} get_tag\n * @property {(n: number) => 1 | 0} parse\n * @property {(n: number) => number} reset\n * @property {{ buffer: ArrayBuffer }} memory\n * \n * @typedef {object} RawStringTemplate\n * @property {readonly string[] | ArrayLike<string>} raw\n * \n * @typedef {WebAssembly.Exports & WasmParserInterface} WasmParser\n*/\n\nconst INSERTION = 'ins()';\n\nconst wasm = await WebAssembly.instantiateStreaming(\n  fetch(new URL('./main.wasm', import.meta.url).toString())\n);\n\nconst instance = wasm.instance;\n\nconst exports = /** @type {WasmParser} */ (instance.exports);\n\nconst $get_tag = exports.get_tag;\nconst $memory = exports.memory;\nconst $parse = exports.parse;\nconst $reset = exports.reset;\n\nexport const mem8 = new Uint8Array($memory.buffer);\nexport const mem32 = new Uint32Array($memory.buffer);\n\n/** @type {Uint8Array} The array of the heap */\nexport let heap8;\n/** @type {Uint32Array} */\nexport let heap32;\n/** @type {Uint8Array} */\nexport let data8;\n\nconst enc = new TextEncoder();\nconst dec = new TextDecoder();\n\n/**\n * \n * @param {Uint8Array} buffer \n * @param {number} start \n * @param {number} end \n * @returns \n */\nconst readFromBuffer = (buffer, start, end) => dec.decode(buffer.slice(start, end));\n\n/** @type {number} - The length of the source */\nlet len;\n\n/* HASH function\nconst hash = (str) => {\n    let h = 5381;\n    for(let i = 0; i < str.length; i++) {\n        let c = str[i];\n      h = ((h << 5) + h) + c.charCodeAt(0);\n    }\n    return h\n};\n*/\n\n/**\n * Parses sources from a tagged template\n * @param {RawStringTemplate} source \n * @param {any[]} values\n * @returns {void}\n */\nexport function parse(source, values) {\n  let holes = values.map(_ => INSERTION);\n  let raw = String.raw(source, ...holes);\n\n  const bytes = enc.encode(raw);\n  len = bytes.byteLength;\n  const dataPtr = $reset(len);\n  mem8.set(bytes, dataPtr);\n  data8 = mem8.subarray(dataPtr);\n\n  const tagPtr = $get_tag();\n  heap8 = mem8.subarray(tagPtr);\n  heap32 = mem32.subarray(tagPtr >> 2);\n}\n\n/**\n * Parses until the next tag, returning 1 if parsing should continue\n * @returns {0|1}\n */\nexport const next = () => $parse(len);\n\n/**\n * Reading a string from the buffer.\n * @param {number} start \n * @param {number} end \n * @returns {string}\n */\nexport const readString = (start, end) => {\n  return readFromBuffer(data8, start, end);\n};\n\n/**\n * Reads the property name.\n * @returns {string}\n */\nexport const readProperty = () => readFromBuffer(data8, heap32[1], heap32[2]);\n\n/**\n * Reads the number of values in the property value.\n * @returns {number}\n */\nexport const readNumberOfValues = () => heap32[3];\n\n/**\n * Gets the first value pointer in the property.\n * @returns {number}\n */\nexport const readFirstValuePointer = () => heap32[4];","// @ts-check\n\n/**\n * @typedef {import('./pinfo').PropertyDefinition} PropertyDefinition\n * @typedef {import('./pinfo').SimplePropertyDefinition} SimplePropertyDefinition\n * @typedef {import('./pinfo').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./pinfo').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./pinfo').MultiPropertyDefinition} MultiPropertyDefinition\n * @typedef {import('./pinfo').BehaviorMultiPropertyDefinition} BehaviorMultiPropertyDefinition\n */\n\nexport const flags = {\n  text: 1 << 0,\n  classToggle: 1 << 1,\n  event: 1 << 2,\n  custom: 1 << 3,\n  each: 1 << 4,\n  prop: 1 << 5,\n  attr: 1 << 6,\n  data: 1 << 7,\n  attach: 1 << 8,\n  behavior: 1 << 9,\n  storeRoot: 1 << 10,\n  storeSet: 1 << 11\n};\n\n export const features = {\n  shorthand: 1 << 0,\n  longhand: 1 << 1,\n  keyed: 1 << 2, // Legacy, needed for sure reason\n  multi: 1 << 3,\n  oldValues: 1 << 4,\n  behavior: 1 << 5,\n  labeled: 1 << 6\n};\n\n/** @type {Record<string, PropertyDefinition>} */\nexport const properties = {\n  /** @type {SimplePropertyDefinition} */\n  'attach-template': {\n    flag: flags.attach,\n    feat: 0,\n    prop: 'attachTemplate',\n    read(el) {\n      let doc = el.ownerDocument || document;\n      let tmpl = doc.createElement('template');\n      tmpl.content.append(...Array.from(el.childNodes));\n      return tmpl;\n    }\n  },\n  /** @type {ShorthandPropertyDefinition} */\n  attr: {\n    flag: flags.attr,\n    feat: features.multi | features.shorthand | features.keyed,\n    prop: 'attr',\n    longhand: ['attr-value', 'attr-toggle'],\n    defaults: ['', true]\n  },\n  /** @type {LonghandPropertyDefinition} */\n  'attr-value': {\n    flag: flags.attr,\n    feat: features.longhand,\n    shorthand: 'attr',\n    index: 0,\n    default: '',\n    read(el, key) {\n      return ('getAttribute' in el) && el.getAttribute(key);\n    }\n  },\n  /** @type {LonghandPropertyDefinition} */\n  'attr-toggle': {\n    flag: flags.attr,\n    feat: features.longhand,\n    shorthand: 'attr',\n    index: 1,\n    default: true,\n    read(el, key) {\n      return ('hasAttribute' in el) && el.hasAttribute(key);\n    }\n  },\n  /** @type {MultiPropertyDefinition} */\n  'class-toggle': {\n    flag: flags.classToggle,\n    feat: features.multi | features.keyed,\n    prop: 'classToggle',\n    read(el, key) {\n      return ('classList' in el) && el.classList.contains(key);\n    }\n  },\n  /** @type {MultiPropertyDefinition} */\n  data: {\n    flag: flags.data,\n    feat: features.multi | features.keyed,\n    prop: 'data',\n    read(el, key) {\n      if(!('dataset' in el))\n        throw new Error(`data can only be used on HTMLElements`);\n      return /** @type {HTMLElement} */(el).dataset[key];\n    }\n  },\n  /** @type {ShorthandPropertyDefinition} */\n  each: {\n    flag: flags.each,\n    feat: features.shorthand,\n    prop: 'each',\n    longhand: ['each-items', 'each-template', 'each-key'],\n    defaults: [[], {}, null]\n  },\n  'each-items': {\n    flag: flags.each,\n    feat: features.longhand,\n    shorthand: 'each',\n    index: 0,\n    default: [],\n    read: () => null,\n  },\n  'each-template': {\n    flag: flags.each,\n    feat: features.longhand,\n    shorthand: 'each',\n    index: 1,\n    default: {},\n    read: () => null\n  },\n  'each-key': {\n    flag: flags.each,\n    feat: features.longhand,\n    shorthand: 'each',\n    index: 2,\n    default: null,\n    read: () => null\n  },\n  /** @type {ShorthandPropertyDefinition} */\n  event: {\n    flag: flags.event,\n    feat: features.multi | features.keyed | features.oldValues | features.shorthand | features.labeled,\n    prop: 'event',\n    longhand: ['event-type', 'event-listener', 'event-capture', 'event-once',\n      'event-passive', 'event-signal'],\n    defaults: [null, false, false, false, undefined]\n  },\n  'event-type': {\n    flag: flags.event,\n    feat: features.keyed | features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 0,\n    default: null,\n    read: () => null\n  },\n  'event-listener': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 1,\n    default: null,\n    read: () => null\n  },\n  'event-capture': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 2,\n    default: false,\n    read: () => false\n  },\n  'event-once': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 3,\n    default: false,\n    read: () => false\n  },\n  'event-passive': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 4,\n    default: false,\n    read: () => false\n  },\n  'event-signal': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 5,\n    default: undefined,\n    read: () => undefined\n  },\n  /** @type {BehaviorMultiPropertyDefinition} */\n  behavior: {\n    flag: flags.behavior,\n    feat: features.multi | features.behavior | features.oldValues,\n    prop: 'behavior'\n  },\n  /** @type {MultiPropertyDefinition} */\n  prop: {\n    flag: flags.prop,\n    feat: features.multi | features.keyed,\n    prop: 'prop',\n    read(el, key) {\n      return /** @type {any} */(el)[key];\n    }\n  },\n  /** @type {SimplePropertyDefinition} */\n  text: {\n    flag: flags.text,\n    feat: 0,\n    prop: 'text',\n    read(el) {\n      return el.textContent;\n    }\n  },\n   /** @type {SimplePropertyDefinition} */\n  'store-root': {\n    flag: flags.storeRoot,\n    feat: 0,\n    prop: 'storeRoot',\n    read: () => null\n  },\n  /** @type {SimplePropertyDefinition} */\n  'store-set': {\n    flag: flags.storeSet,\n    feat: 0,\n    prop: 'storeSet',\n    read: () => null\n  }\n};","// @ts-check\nimport { properties, features } from './property.js';\n\n/** @typedef {import('./rule').Rule} Rule */\n/** @typedef {import('./property').PropertyDefinition} PropertyDefinition */ \n/** @typedef {import('./value').Value} Value */\n/** @typedef {import('./template').ValueTemplate} ValueTemplate */\n\nexport class Declaration {\n  /**\n   * \n   * @param {Rule} rule \n   * @param {string} propertyName \n   * @param {number} sourceOrder\n   * @param {ValueTemplate} template\n   */\n  constructor(rule, propertyName, sourceOrder, template) {\n    /** @type {Rule} */\n    this.rule = rule;\n    /** @type {string} */\n    this.propertyName = propertyName;\n    /** @type {ValueTemplate | null} */\n    this.keyTemplate = null;\n    /** @type {number} */\n    this.sourceOrder = sourceOrder;\n    /** @type {ValueTemplate} */\n    this.template = template;\n    /** @type {number} */\n    this.flags = 0;\n  }\n\n  init() {\n    /** @type {PropertyDefinition | undefined} */\n    let defn = properties[this.propertyName];\n    if(defn) {\n      if(defn.feat & features.multi) {\n        this.flags |= flags.multi;\n      }\n      if(defn.feat & features.labeled) {\n        this.flags |= flags.label;\n      }\n      if(defn.feat & features.longhand) {\n        this.flags |= flags.longhand;\n      } else if(defn.feat & features.shorthand) {\n        this.flags |= flags.shorthand;\n      } else if(defn.feat & features.behavior) {\n        this.flags |= flags.behavior;\n      }\n    }\n  }\n}\n\nexport const flags = {\n  shorthand: 1 << 0,\n  longhand: 1 << 1,\n  multi: 1 << 2,\n  behavior: 1 << 3,\n  label: 1 << 4,\n};","// @ts-check\n\n/**\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./types').RootElement} RootElement\n */\n\nconst rootSelect = (/** @type {RootElement} */ el) => [el];\n/**\n * @param {RootElement} el\n * @this {Rule}\n * @returns {NodeListOf<Element>}\n */\nfunction querySelect(el) {\n  return el.querySelectorAll(this.selector);\n}\n\nexport class Rule {\n  /**\n   * @param {string} selector\n   */\n  constructor(selector) {\n    /** @type {String} */\n    this.selector = selector;\n    /** @type {Array<Declaration>} */\n    this.declarations = [];\n    /** @type {number} */\n    this.specificity = 0;\n    /** @type {(el: RootElement) => Iterable<Element | ShadowRoot | Document>} */\n    this.querySelectorAll = selector === ':root' ? rootSelect : querySelect;\n  }\n\n  /** @param {Declaration} declaration */\n  addDeclaration(declaration) {\n    this.declarations.push(declaration);\n  }\n}","\n/**\n * \n * @param {string} dataPropName \n * @param {string} dataSelector \n * @param {string} propName \n * @returns \n */\nexport function lookup(element, dataPropName, dataSelector, propName) {\n  /** @type {Element | null} */\n  let el = element;\n  do {\n    if(el.hasAttribute(dataPropName)) {\n      return /** @type {any} */(el)[Symbol.for(propName)];\n    }\n    el = element.closest(dataSelector);\n  } while(el);\n}","\n/**\n * Takes a custom property name like --my-prop and makes it \n * PascalCase like MyProp for use with dataset.\n * @param {string} propertyName\n * @returns {string}\n */\nexport function pascalCase(propertyName) {\n  return propertyName.replace(/-?-([a-zA-Z])/g, (_whole, letter) => {\n    return letter.toUpperCase();\n  });\n}\n\n/**\n * Creates a key for dataset for looking up a key\n * @param {string} keyName\n * @returns {string}\n */\n export function datasetKey(propertyName) {\n  return 'corset' + pascalCase(propertyName);\n}\n\n/**\n * Creates a key for dataset for looking up custom properties\n * @param {string} propertyName \n * @returns {string}\n */\nexport function datasetPropKey(propertyName) {\n  return 'corsetProp' + pascalCase(propertyName);\n}","// @ts-check\nimport { pascalCase } from './custom-prop.js';\n\nexport const getKeySymbol = Symbol.for('corset.getKey');\n\n/**\n * @typedef {import('./sheet').Root} Root\n */\n\nexport class Store extends Map {\n  /** @type {() => any} */\n  #update;\n  /**\n   * \n   * @param {Root} root \n   */\n  constructor(root, updateMount = true) {\n    super();\n    /** @type {Root} */\n    this.root = root;\n    /** @type {() => any} */\n    this.#update = updateMount ?\n      this.root.mount ?\n      this.root.mount.update.bind(this.root.mount) :\n      /** @type {() => void} */(Function.prototype) :\n      this.root.update.bind(this.root)\n  }\n  /**\n   * \n   * @param {any} key\n   * @returns {any}\n   */\n  [getKeySymbol](key) {\n    return this.get(key);\n  }\n  /**\n   * \n   * @param {string} k \n   * @param {any} v \n   * @returns \n   */\n  set(k, v) {\n    super.set(k, v);\n    this.#update();\n    return this;\n  }\n}\n\n/**\n * \n * @param {string} storeName \n * @returns {string}\n */\nexport const storePropName = storeName => `corset.store.${storeName}`;\n/**\n * \n * @param {string} storeName \n * @returns {string}\n */\nexport const storeDataName = storeName => `data-corset-store-${storeName}`;\n/**\n * \n * @param {string} storeName \n * @returns {string}\n */\nexport const storeDataPropName = storeName => 'corsetStore' + pascalCase('-' + storeName);","// @ts-check\nimport { lookup } from './scope.js';\nimport { Store } from './store.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./compute').ComputedValue} ComputedValue\n * @typedef {import('./function').FunctionContext} FunctionContext\n * @typedef {import('./types').Value} Value\n * @typedef {import('./types').ValueType} ValueType\n * @typedef {import('./function').ICorsetFunctionClass} ICorsetFunctionClass\n * @typedef {import('./function').ICorsetFunction} ICorsetFunction\n */\n\nexport const NO_VALUE = Symbol('corset.noValue');\n\n/**\n * \n * @param {any} value \n * @returns {ValueType}\n */\n export const anyValue = value => \n /** @implements {Value} */\n class AnyValue{get(){ return value }};\n\n/** @implements {Value} */\nexport class InsertionValue {\n  constructor() {\n    /** @type {number} */\n    this.current = 0;\n    /** @type {any} */\n    this.value = NO_VALUE;\n  }\n  /**\n   * \n   * @param {[number]} args \n   * @param {Binding} _binding \n   * @param {Map<string, any>} _props\n   * @param {Changeset} changeset \n   * @returns {boolean}\n   */\n  check([index], _binding, _props, {values}) {\n    let value = values[index];\n    if(this.value !== value) {\n      this.value = value;\n      return true;\n    }\n    return false;\n  }\n  get() {\n    return this.value;\n  }\n}\n\n/** @implements {Value} */\nexport class SpaceSeparatedListValue {\n  /**\n   * \n   * @param {any[]} values \n   * @returns \n   */\n  get(values = []) {\n    return values;\n  }\n}\n\nexport class CommaSeparatedListValue extends SpaceSeparatedListValue {}\n\n/** @implements {Value} */\nexport class PlaceholderValue {\n  constructor() {\n    this.current = 0;\n    /** @type {NO_VALUE | ComputedValue} */\n    this.compute = NO_VALUE;\n    /** @type {any} */\n    this.value = null;\n  }\n  /**\n   * \n   * @param {[string, any]} args \n   * @param {Binding} binding \n   * @param {Map<string, any>} _props\n   * @param {Changeset} changeset \n   * @returns {boolean}\n   */\n  check(args, binding, _props, changeset) {\n    let check = false;\n    if(changeset.selectors) check = true;\n    else if(this.compute === NO_VALUE) check = true;\n    else {\n      this.compute.dirty(changeset);\n      let value = this.compute.check(changeset);\n      if(value !== this.value) {\n        this.value = value;\n        return true;\n      }\n      return false;\n    }\n    if(check) {\n      let scope = this.#get(args, binding);\n      if(scope) {\n        if(scope.value !== this.value || scope.compute !== this.compute) {\n          this.compute = scope.compute;\n          this.value = scope.value;\n          return true;\n        } else {\n          // Nothing has changed.\n          return false;\n        }\n      } else if(args.length > 1) {\n        let value = args[1];\n        if(!this.value || value !== this.value[0]) {\n          this.value = [value];\n          return true;\n        }\n        return false;\n      }\n    }\n    return false;\n  }\n  /**\n   * \n   * @param {[string, any]} args \n   * @param {Binding} param1 \n   * @returns \n   */\n  #get(args, { element }) {\n    let [propName] = args;\n    let dataName = 'prop-' + propName.slice(2);\n    let dataPropName = 'data-corset-' + dataName;\n    let dataSelector = '[' + dataPropName + ']';\n    return lookup(element, dataPropName, dataSelector, propName);\n  }\n  get() {\n    return this.value;\n  }\n}\n\n/**\n * \n * @param {ICorsetFunctionClass} CorsetFunction \n * @returns {ValueType}\n */\nexport const functionValue = (CorsetFunction) => {\n  /** @type {ICorsetFunction | undefined} */\n  let prototype = CorsetFunction.prototype;\n  if(typeof prototype !== 'object') throw new Error(`Functions must contain a prototype`);\n  /** @type {ICorsetFunction['call']} */\n  let callValue = prototype.call;\n\n  class FunctionValue {\n    static inputProperties = CorsetFunction.inputProperties;\n\n    /**\n     * @param {Binding} binding\n     */\n    constructor(binding) {\n      /** @type {FunctionContext} */\n      this.context = Object.create(binding, {\n        createStore: {\n          value() {\n            return new Store(binding.root, false);\n          }\n        }\n      });\n      /** @type {ICorsetFunction} */\n      this.fn = new CorsetFunction();\n    }\n    /**\n     * \n     * @param {any[]} args \n     * @param {Binding} _binding \n     * @param {Map<string, any> | null} props\n     * @returns {any}\n     */\n    get(args, _binding, props) {\n      return callValue.call(this.fn, args, props, this.context);\n    }\n  }\n\n  if(prototype.check) {\n    let checkValue = prototype.check;\n    /**\n     * \n     * @param {any[]} args \n     * @param {Binding} _binding \n     * @param {Map<string, any> | null} props\n     * @param {Changeset} changeset\n     */\n    FunctionValue.prototype.check = function(args, _binding, props, changeset) {\n      return checkValue.call(this.fn, args, props, this.context, changeset);\n    };\n  }\n\n  return FunctionValue;\n}","// @ts-check\n\nimport { PlaceholderValue, SpaceSeparatedListValue } from './value.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./value').Value} Value\n * @typedef {import('./types').CheckedValue} CheckedValue\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * \n * @typedef {(c: Changeset, v: number) => number} VersionCalculate\n */\n\nexport class ComputedValue {\n  /** @type {boolean} */\n  #initial = true;\n  /** @type {any} */\n  #value;\n  /** @type {WeakMap<Changeset, boolean>} */\n  #dirty = new WeakMap();\n  /** @type {CheckedValue['check'] | undefined} */\n  #check;\n  /**\n   * \n   * @param {ValueTemplate} template \n   * @param {Binding} binding \n   * @param {number} index\n   */\n  constructor(template, binding, index = 0) {\n    /** @type {Binding} */\n    this.binding = binding;\n    /** @type {number} */\n    this.index = index;\n    /** @type {any[]} */\n    this.args = [];\n    /** @type {ComputedValue[]} */\n    this.argDeps = [];\n    /** @type {Map<string, ComputedValue> | null} */\n    this.inputDeps = null;\n    /** @type {Map<string, any> | null} */\n    this.inputProps = null;\n    /** @type {Value} */\n    this.raw = hydrate(this, template);\n    /** @type {() => any[]} */\n    this.listValue = this.raw instanceof SpaceSeparatedListValue ?\n      () => this.#value :\n      () => [this.#value];\n\n    // Private\n    this.#value = null;\n    this.#check = this.raw.check;\n  }\n  /**\n   * \n   * @param {number} index \n   * @param {ComputedValue} dep\n   * @param {Changeset} changeset\n   */\n  set(index, dep, changeset) {\n    let deps = this.argDeps;\n    if(deps[index] !== dep) {\n      this.#dirty.set(changeset, true);\n    }\n    deps[index] = dep;\n  }\n  /**\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  dirty(changeset) {\n    if(this.#initial) {\n      this.calculate(changeset);\n      this.#dirty.set(changeset, true);\n      this.#initial = false;\n    }\n    if(this.#dirty.has(changeset)) {\n      return /** @type {boolean} */(this.#dirty.get(changeset));\n    }\n    this.calculate(changeset);\n    return /** @type {boolean} */(this.#dirty.get(changeset));\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   */\n  compute(changeset) {\n    this.#value = call(this, changeset, this.raw.get);\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns {any}\n   */\n  check(changeset) {\n    if(this.dirty(changeset)) {\n      this.compute(changeset);\n    }\n    return this.#value;\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns {boolean}\n   */\n  calculate(changeset) {\n    if(this.#dirty.has(changeset)) {\n      return /** @type {boolean} */(this.#dirty.get(changeset));\n    }\n    let dirty = false;\n    if(this.#check) {\n      if(call(this, changeset, this.#check)) {\n        dirty = true;\n      }\n    }\n\n    for(let dep of this.#allDeps()) {\n      if(dep.calculate(changeset)) {\n        dirty = true;\n      }\n    }\n\n    this.#dirty.set(changeset, dirty);\n    return dirty;\n  }\n  * #allDeps() {\n    yield * this.argDeps;\n    if(this.inputDeps) {\n      yield * this.inputDeps.values();\n    }\n  }\n}\n\n/**\n * \n * @param {ComputedValue} compute \n * @param {ValueTemplate} template \n * @returns {Value}\n */\nfunction hydrate(compute, template) {\n  let value = new template.Value(compute.binding);\n  for(let dep of template.deps) {\n    compute.argDeps.push(new ComputedValue(dep, compute.binding));\n  }\n  let inputProperties = template.inputProperties;\n  if(inputProperties) {\n    compute.inputProps = new Map();\n    compute.inputDeps = new Map();\n    for(let [propName, template] of inputProperties) {\n      compute.inputDeps.set(propName, new ComputedValue(template, compute.binding));\n    }\n  }\n  return value;\n}\n\n/**\n * @param {ComputedValue} compute \n * @param {Changeset} changeset\n * @param {Value['get'] | CheckedValue['check']} method\n * @returns {any}\n */\nfunction call(compute, changeset, method) {\n  let {args, binding, raw: value, inputProps: props} = compute;\n  if(compute.inputDeps) {\n    for(let [propName, v] of compute.inputDeps) {\n      let value = v.check(changeset);\n      if((v.raw instanceof PlaceholderValue) && Array.isArray(value)) {\n        value = value[0];\n      }\n      /** @type {Map<string, any>} */(props).set(propName, value);\n    }\n  }\n  args.length = 0;\n  for(let v of compute.argDeps) {\n    if(v.raw instanceof PlaceholderValue) {\n      let values = v.check(changeset);\n      if(values) args.push(...values);\n    }\n    else\n      args.push(v.check(changeset)); \n  }\n  return method.call(value, args, binding, props, changeset);\n}","// @ts-check\nimport { ComputedValue } from './compute.js';\nimport { NO_VALUE } from './value.js';\n\n/**\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./property').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./property').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./pinfo').PropertyPropName} PropertyPropName\n * @typedef {import('./sheet').Root} Root\n * @typedef {import('./types').RootElement} RootElement\n */\n\n/**\n * \n * @param {any[]} sorted \n * @param {any} item \n * @param {(a: any, b: any) => boolean} comparator\n * @returns {number}\n */\n function binaryInsert(sorted, item, comparator) {\n  if(sorted.length === 0) {\n    sorted.push(item);\n    return 0;\n  }\n  let low = 0, high = sorted.length - 1, mid = 0;\n  while (low <= high) {\n    mid = low + (high - low >> 1);\n    if(comparator(sorted[mid], item)) {\n      low = mid + 1;\n    } else {\n      high = mid -1;\n    }\n  }\n\n  if(comparator(sorted[mid], item)) {\n    mid++;\n  }\n\n  sorted.splice(mid, 0, item);\n  return mid;\n}\n\n/**\n * Sort a declaration first by selector specificity, then by rule index,\n * then by declaration index\n * @param {Declaration} d1\n * @param {Declaration} d2\n * @returns {boolean}\n */\nfunction compare(d1, d2) {\n  return d1.rule.specificity === d2.rule.specificity ?\n    d1.sourceOrder < d2.sourceOrder :\n    d1.rule.specificity < d2.rule.specificity;\n}\n\nexport class Binding {\n  /**\n   * \n   * @param {string} propertyName\n   * @param {Root} root\n   * @param {Element | ShadowRoot | Document} element\n   */\n  constructor(propertyName, root, element) {\n    this.root = root;\n    /** @type {string} */\n    this.propertyName = propertyName;\n    /** @type {RootElement} */\n    this.rootElement = root.rootElement;\n    /** @type {Element | ShadowRoot | Document} */\n    this.element = element;\n    /** @type {Declaration[]} */\n    this.declarations = [];\n    /** @type {Map<Declaration, ComputedValue>} */\n    this.computedValues = new Map();\n    /** @type {ComputedValue | null} */\n    this.compute = null;\n    /** @type {any} */\n    this.value = NO_VALUE;\n    /** @type {any} */\n    this.initial = NO_VALUE;\n  }\n  /**\n   * \n   * @param {Declaration} declaration\n   * @returns {ComputedValue}\n   */\n  add(declaration) {\n    return this.addTemplate(declaration, declaration.template);\n  }\n  /**\n   * \n   * @param {Declaration} declaration \n   */\n  push(declaration) {\n    binaryInsert(this.declarations, declaration, compare);\n  }\n  /**\n   * \n   * @param {Declaration} declaration \n   * @param {ValueTemplate} template \n   * @param {number} [index]\n   * @returns {ComputedValue}\n   */\n  addTemplate(declaration, template, index) {\n    /** @type {ComputedValue} */\n    let compute = new ComputedValue(template, this, index);\n    this.computedValues.set(declaration, compute);\n    return compute;\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns \n   */\n  dirty(changeset) {\n    if(this.value === NO_VALUE) {\n      return true;\n    } else {\n      let compute = this.compute;\n      this.compute = this.#find();\n      if(compute !== this.compute) return true;\n      return compute ? compute.dirty(changeset) : false;\n    }\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   */\n  update(changeset) {\n    if(this.compute === null) {\n      this.compute = this.#find();\n    }\n    if(this.compute === null) {\n      this.value = this.initial;\n    } else {\n      this.value = this.compute.check(changeset);\n    }\n    return this.value;\n  }\n  /**\n   * \n   * @returns {any[]}\n   */\n  getList() {\n    return this.compute?.listValue() || [];\n  }\n  /**\n   * Whether this binding has received a value yet or not.\n   * @returns {boolean}\n   */\n  hasValue() {\n    return this.value !== NO_VALUE;\n  }\n  /**\n   * \n   * @returns {ComputedValue | null}\n   */\n  #find() {\n    let declaration = this.#firstMatch();\n    if(declaration) {\n      /** @type {ComputedValue} */\n      let compute = /** @type {ComputedValue} */(this.computedValues.get(declaration));\n      return compute;\n    }\n    return null;\n  }\n  *walk() {\n    let { element } = this;\n    let sorted = this.declarations;\n\n    let i = sorted.length;\n    /** @type {Declaration} */\n    let declaration;\n    while(i > 0) {\n      i--;\n      declaration = sorted[i];\n      if(this.matches(declaration.rule.selector)) {\n        yield declaration;\n      }\n    }\n  }\n  /**\n   * \n   * @param {string} selector \n   * @returns {boolean}\n   */\n  matches(selector) {\n    let element = this.element;\n    if(selector === ':root')\n      return true;\n    else if('matches' in element)\n      return element.matches(selector);\n    else return false;\n  }\n  /**\n   * \n   * @returns {Declaration | void}\n   */\n  #firstMatch() {\n    for(let declaration of this.walk()) {\n      return declaration;\n    }\n  }\n}","// @ts-check\n\n/**\n * @typedef {{}} Constant\n * \n * @typedef {((value: string) => Constant) & { map: Map<string, Constant>; for: (s: string) => Constant; base: Object; is: (value: any) => boolean; }} ConstantCreator\n */\n\nconst ConstantMethods = {\n  /**\n  * \n  * @param {string} value \n  * @returns {Constant}\n  * @this {ConstantCreator}\n  */\n  for(value) {\n    let map = /** @type {Map<string, Constant>} */(/** @type {unknown} */(this.map));\n    return /** @type {Constant} */(map.get(value) ||\n      (map.set(value, this(value))) && map.get(value));\n  },\n\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   * @this {ConstantCreator}\n   */\n  is(value) {\n    return Object.prototype.isPrototypeOf.call(this.base, value);\n  }\n};\n\n/**\n * \n * @returns {ConstantCreator}\n */\nlet createConstant = () => {\n  /**\n   * @param {string} value\n   */\n  function ConstantBase(value) {\n    return Object.create(ConstantBase.base, {\n      name: { enumerable: false, writable: false, configurable: false, value }\n    });\n  }\n  ConstantBase.base = Object.create(null);\n  ConstantBase.map = new Map();\n  Object.assign(ConstantBase, ConstantMethods);\n  return /** @type {ConstantCreator} */(/** @type {unknown} */(ConstantBase));\n};\n\nexport const Name = createConstant();\nexport const Keyword = createConstant();\n\nexport const KEYWORD_REVERT_SHEET = Keyword('revert-sheet');\nexport const KEYWORD_ALL = Keyword('all');","// @ts-check\n\nimport { NO_VALUE } from './value.js';\n\n/**\n * @template {string | null} K\n * @extends {Array}\n */\nexport class SparseArray extends Array {\n  /**\n   * \n   * @param {number} len \n   */\n  constructor(len) {\n    super(len);\n    this.fill(NO_VALUE);\n    this.numberOfValues = 0;\n  }\n  /**\n   * \n   * @param {number} index \n   * @returns \n   */\n  empty(index) {\n    return this[index] === NO_VALUE;\n  }\n  /**\n   * @returns {boolean}\n   */\n  full() {\n    return this.numberOfValues === this.length;\n  }\n  /**\n   * \n   * @param {number} index \n   * @param {any} item \n   */\n  set(index, item) {\n    this[index] = item;\n    this.numberOfValues++;\n  }\n}","// @ts-check\n\nimport { anyValue, PlaceholderValue } from './value.js';\n\n/**\n * @typedef {import('./value').ValueType} ValueType\n */\n\n/**\n * \n * @typedef {Object} ValueTemplate\n * @property {ValueType} Value\n * @property {ValueTemplate[]} deps\n * @property {Map<string, ValueTemplate> | null} [inputProperties]\n */\n\n/**\n * \n * @param {ValueType} Value \n * @param {ValueTemplate[]} deps\n * @returns {ValueTemplate}\n */\nexport function createValueTemplate(Value, deps = []) {\n  /** @type {ValueTemplate} */\n  let template = {\n    Value,\n    deps,\n    inputProperties: null\n  };\n\n  if(Value.inputProperties) {\n    /** @type {Map<string, ValueTemplate>} */\n    let map = new Map();\n    for(let propName of Value.inputProperties) {\n      map.set(propName, createValueTemplate(PlaceholderValue, [\n        createValueTemplate(anyValue(propName))\n      ]));\n    }\n    template.inputProperties = map;\n  }\n\n  return template\n}","// @ts-check\nimport { Binding } from './binding.js';\nimport { ComputedValue } from './compute.js';\nimport { flags as declFlags } from './declaration.js';\nimport { Name } from './constants.js';\nimport { properties, features } from './property.js';\nimport { SparseArray } from './sparse-array.js';\nimport { createValueTemplate } from './template.js';\nimport { SpaceSeparatedListValue } from './value.js';\nimport { KEYWORD_ALL, KEYWORD_REVERT_SHEET } from './constants.js';\n\n/**\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./constants').Constant} Constant\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./pinfo').MultiPropertyDefinition} MultiPropertyDefinition\n * @typedef {import('./property').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./property').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./property').BehaviorMultiPropertyDefinition} BehaviorMultiPropertyDefinition\n */\n\n/**\n * \n * @param {Declaration} declaration \n * @returns {ValueTemplate}\n */\n function createPrependedKeyedTemplate(declaration) {\n  return createValueTemplate(SpaceSeparatedListValue, [\n    /** @type {ValueTemplate} */(declaration.keyTemplate)\n  ].concat(declaration.template.deps))\n}\n\n/**\n * @typedef {string | Constant | null | MountedBehaviorType} MultiBindingKey\n */\n\n/**\n * @template {string | Constant | Array<any> | MountedBehaviorType} K\n */\nexport class MultiBinding extends Binding {\n  /**\n   * @param {ShorthandPropertyDefinition | MultiPropertyDefinition | BehaviorMultiPropertyDefinition} defn\n   * @param {ConstructorParameters<typeof Binding>} args\n   */\n  constructor(defn, ...args) {\n    super(...args);\n\n    /** @type {ShorthandPropertyDefinition | MultiPropertyDefinition | BehaviorMultiPropertyDefinition} */\n    this.defn = defn;\n\n    /** @type {number} */\n    this.numberOfValues =\n      /** @type {ShorthandPropertyDefinition} */(defn).longhand?.length || 2;\n\n    /** @type {number} */\n    this.numberOfValuesWithKey = this.numberOfValues + (defn.feat & features.keyed ? 1 : 0);\n\n    /** @type {Set<MultiBindingKey>} */\n    this.active = new Set();\n    /** @type {Map<MultiBindingKey, readonly any[]>} */\n    this.initial = new Map();\n    /** @type {Map<MultiBindingKey, any[]> | null} */\n    this.oldValues = defn.feat & features.oldValues ? new Map() : null;\n  }\n  /**\n  * \n  * @param {Declaration} declaration \n  */\n  add(declaration) {\n    this.push(declaration);\n\n    let propName = declaration.propertyName;\n    switch(declaration.flags) {\n      // Unkeyed multi\n      case declFlags.multi | declFlags.shorthand:\n      // behavior: mount(Behavior)\n      case declFlags.multi | declFlags.behavior:\n      // event: [label] type callback\n      case declFlags.multi | declFlags.shorthand | declFlags.label:\n      // class-toggle: one \"one\", two \"two\"\n      case declFlags.multi:\n      // each: ${items} select(template)\n      case declFlags.shorthand: {\n        return this.addTemplate(declaration, declaration.template);\n      }\n      // each-items: ${items}\n      case declFlags.longhand:\n      // event-once: [label] true\n      case declFlags.longhand | declFlags.label: {\n        let defn = /** @type {LonghandPropertyDefinition} */(properties[propName]);\n        return this.addTemplate(declaration, declaration.template, defn.index);\n      }\n      default: {\n        throw new Error('Unknown property type');\n      }\n    }\n  }\n  /**\n  * \n  * @param {Changeset} changeset \n  * @returns {Generator<[[K, ...any[]], boolean], void, unknown>}\n  */\n  * calculate(changeset) {\n    let sorted = this.declarations;\n    let active = new Set(this.active);\n    /** @type {Set<MultiBindingKey>} */\n    let unset = new Set();\n\n    /**\n     * @typedef {SparseArray<K extends string ? K : null>} KeyedSparseArray\n     */\n\n    /** @type {Map<string | Constant | null, KeyedSparseArray>} */\n    let valueMap = new Map();\n    let getValueList =\n    /**\n     * \n     * @param {string | Constant | null} key \n     * @param {number} numOfValues \n     * @return {KeyedSparseArray}\n     */\n    function(key, numOfValues) {\n      /** @type {KeyedSparseArray} */\n      let valueList;\n      if(valueMap.has(key))\n        valueList = /** @type {KeyedSparseArray} */(valueMap.get(key));\n      else {\n        valueList = new SparseArray(numOfValues);\n        valueMap.set(key, valueList);\n      }\n      return valueList;\n    };\n\n    /** @type {Set<string | Constant | null>} */\n    let dirtyKeys = new Set();\n\n    let i = sorted.length;\n    /** @type {Declaration} */\n    let declaration;\n    loop: while(i > 0) {\n      i--;\n      declaration = sorted[i];\n      if(this.matches(declaration.rule.selector)) {\n        let compute = /** @type {ComputedValue} */(this.computedValues.get(declaration));\n\n        let dirty = compute.dirty(changeset);\n        let computedValue = compute.check(changeset);\n\n        switch(declaration.flags) {\n          // attr: \"type\" \"text\"\n          case declFlags.multi | declFlags.shorthand:\n          // class-toggle: one \"one\", two \"two\"\n          case declFlags.multi: {\n            for(let values of /** @type {[K, ...any[]][]} */(computedValue)) {\n              let key = /** @type {string | Constant} */(values[0]);\n\n              let idx = Name.is(key) ? 1 : 0;\n              if(values[1] === KEYWORD_REVERT_SHEET) {\n                if(key === KEYWORD_ALL) {\n                  for(let val of this.active) {\n                    unset.add(val);\n                  }\n                  break;\n                }\n                else {\n                  unset.add(key);\n                  break;\n                }\n              } else if(unset.has(key) || typeof key === 'undefined') {\n                break;\n              }\n\n              if(values.length === 1) break;\n              this.#bookkeep(active, key);\n              if(dirty) dirtyKeys.add(key);\n              let valueList = getValueList(key, this.numberOfValuesWithKey);\n              for(let i = 0; idx < values.length; i++, idx++) {\n                if(valueList.empty(i))\n                  valueList.set(i, values[idx]);\n              }\n            }\n            break;\n          }\n          // event: [label] type callback, [another-label] type callback\n          case declFlags.multi | declFlags.shorthand | declFlags.label: {\n            for(let values of /** @type {[K, ...any[]][]} */(computedValue)) {\n              let key = /** @type {string | Constant} */(values[0]);\n              let isName = Name.is(key);\n              if(!isName) {\n                key = Name.for('corset.default.' + key);\n              }\n              else\n                values = /** @type {[K, ...any[]]} */(values.slice(1));\n\n              this.#bookkeep(active, key, isName ? values[1] : values[0]);\n              let valueList = getValueList(key, this.numberOfValues);\n              for(let i = 0; i < values.length; i++) {\n                if(valueList.empty(i))\n                  valueList.set(i, values[i]);\n              }\n              if(dirty) dirtyKeys.add(key);\n            }\n            break;\n          }\n          // behavior: mount(Behavior)\n          case declFlags.multi | declFlags.behavior: {\n            for(let [values] of computedValue) {\n              let Behavior = values[0];\n              this.#bookkeep(active, Behavior);\n              let allValues = this.#appendToValues(Behavior, values);\n              yield [allValues, dirty];\n              this.oldValues?.set(Behavior, values);\n            }\n            break loop;\n          }\n          // each-items: ${items};\n          case declFlags.longhand: {\n            let keyed = this.defn.feat & features.keyed;\n            /** @type {string | null} */\n            let key = keyed ? computedValue[0] : null;\n            /** @type {any} */\n            let propValue = keyed ? computedValue[1] : computedValue[0];\n            let idx = compute.index + (keyed ? 1 : 0);\n\n            this.#bookkeep(active, key);\n            let valueList = getValueList(key, this.numberOfValuesWithKey);\n            if(keyed && valueList.empty(0))\n              valueList.set(0, computedValue[0]);\n            if(valueList.empty(idx))\n              valueList.set(idx, propValue);\n            if(dirty)\n              dirtyKeys.add(key);\n\n            if(valueList.full()) {\n              if(this.oldValues) this.oldValues.set(key, Array.from(valueList));\n              yield [\n                /** @type {[K, ...any[]]} */(/** @type {unknown} */(valueList)),\n                dirty || dirtyKeys.has(key)\n              ];\n              valueMap.delete(key);\n              dirtyKeys.delete(key);\n              break;\n            }\n\n            break;\n          }\n          // event-once: [name] true;\n          case declFlags.longhand | declFlags.label: {\n            let hasLabel = Name.is(computedValue[0]);\n            /** @type {Name} */\n            let key = hasLabel ? computedValue[0] : Name.for('corset.default.' + computedValue[0]);\n            /** @type {any} */\n            let propValue = computedValue[1];\n\n            this.#bookkeep(active, key, computedValue[0]);\n            let valueList = getValueList(key, this.numberOfValues);\n            if(!hasLabel && valueList.empty(0))\n              valueList.set(0, computedValue[0]);\n            if(valueList.empty(compute.index))\n              valueList.set(compute.index, propValue);\n            if(dirty)\n              dirtyKeys.add(key);\n            break;\n          }\n          // each: ${items} select(template)\n          case declFlags.shorthand: {\n            this.#bookkeep(active, null);\n            yield [this.#appendToValues(null, computedValue, false), dirty];\n            break;\n          }\n          default: {\n            throw new Error(`This is not supported`);\n          }\n        }\n      }\n    }\n\n    // Fill in the defaults by looking at the valueMap for holes.\n    for(let [key, values] of valueMap) {\n      if(!dirtyKeys.has(key)) continue;\n      // valueMap is always appended from a longhand prop.\n      let numOfValues = this.numberOfValues;\n      let keyed = this.defn.feat & features.keyed;\n      let i = keyed ? 1 : 0;\n      while(i < numOfValues) {\n        if(values.empty(i)) {\n          values[i] = /** @type {ShorthandPropertyDefinition} */(this.defn).defaults[i - (keyed ? 1 : 0)];\n        }\n        i++;\n      }\n      if(this.oldValues) {\n        let current = this.oldValues.get(key);\n        this.oldValues.set(key, values.slice());\n        if(current) {\n          values.push(...current);\n        }\n      }\n      yield [/** @type {[K, ...any[]]} */(/** @type {unknown} */(values)), true];\n    }\n\n    // Yield out to reset to initial state.\n    for(let key of active) {\n      let initialValues = this.initial.get(key) || [];\n      let valuesWithKey = this.defn.feat & features.keyed && !Name.is(key) ? [key, ...initialValues] : Array.from(initialValues);\n      let allValues = this.#appendToValues(key, /** @type {[K, ...any[]]} */(valuesWithKey));\n      yield [allValues, true];\n      this.active.delete(key);\n    }\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns {Generator<any[], void, unknown>}\n   */\n  * values(changeset) {\n    for(let [values] of this.calculate(changeset)) {\n      yield values;\n    }\n  }\n  /**\n   * \n   * @returns {Generator<any[], void, unknown>}\n   */\n  * current() {\n    if(!this.oldValues) return;\n    for(let [key, values] of this.oldValues) {\n      /** @type {any[]} */\n      let out = key ? [key] : [];\n      yield out.concat(values);\n    }\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   */\n  * changes(changeset) {\n    for(let [values, dirty] of this.calculate(changeset)) {\n      if(dirty)\n        yield values;\n    }\n  }\n  /**\n   * \n   * @param {string | Constant | MountedBehaviorType} key \n   * @param {string} [type]\n   */\n  #setInitials(key, type) {\n    if(!this.initial.has(key)) {\n      /** @type {any[]} */\n      let values = [];\n      if(this.defn.longhand) {\n        let i = 0, len = this.defn.longhand.length;\n        while(i < len) {\n          let lhDefn = /** @type {LonghandPropertyDefinition} */(properties[this.defn.longhand[i]]);\n          values[i] = lhDefn.read(\n            this.element,\n            /** @type {string} */(key)\n          );\n          i++;\n        }\n        if(type) values[0] = type;\n      } else if(this.defn.feat & features.behavior) {\n        values = [null, null];\n      } else if(this.defn.read) {\n        values[0] = this.defn.read(this.element, /** @type {string} */(key));\n      }\n      this.initial.set(key, Object.freeze(values));\n    }\n  }\n  /**\n   * \n   * @param {Set<MultiBindingKey>} active \n   * @param {MultiBindingKey} key \n   * @param {string} [type]\n   */\n  #bookkeep(active, key, type) {\n    active.delete(key);\n    if(key !== null) this.#setInitials(key, type);\n    this.active.add(key);\n  }\n  /**\n   * @param {MultiBindingKey} key\n   * @param {[K, ...any[]]} values \n   * @param {boolean} keyed\n   * @returns {[K, ...any[]]}\n   */\n  #appendToValues(key, values, keyed = true) {\n    if(values.length === this.numberOfValuesWithKey && this.oldValues === null)\n      return values;\n    /** @type {any[]} */\n    let append = [];\n    let keyIsName = Name.is(key);\n    if(typeof key === 'string') append.push(key);\n    let i = append.length + values.length;\n    let d = keyed ? 1 : 0;\n    let numOfValues = keyIsName ? this.numberOfValues : this.numberOfValuesWithKey;\n    while(i < numOfValues) {\n      append.push(/** @type {ShorthandPropertyDefinition} */(this.defn).defaults[i - d]);\n      i++;\n    }\n    if(this.oldValues && this.oldValues.has(key)) {\n      let oldValues = /** @type {any[]} */(this.oldValues.get(key));\n      append.push(...oldValues);\n    }\n    return /** @type {[K, ...any[]]} */(values.concat(append));\n  }\n}","// @ts-check\n\nimport { Binding } from './binding.js';\nimport { properties } from './property.js';\n\n/**\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./property').SimplePropertyDefinition} SimplePropertyDefinition\n * @typedef {import('./sheet').Root} Root\n */\n\nexport class SimpleBinding extends Binding {\n  /**\n   * \n   * @param {SimplePropertyDefinition} defn\n   * @param {string} propName \n   * @param {[Root, Element | ShadowRoot | Document]} args \n   */\n  constructor(defn, propName, ...args) {\n    super(propName, ...args);\n\n    /** @type {SimplePropertyDefinition} */\n    this.defn = defn;\n\n    /** @type {any} */\n    this.initial = this.defn.read(this.element);\n  }\n}","// @ts-check\n\nimport { Binding } from './binding.js';\nimport { MultiBinding } from './multi-binding.js';\nimport { SimpleBinding } from './simple-binding.js';\nimport { flags, properties, features } from './property.js';\n\n/**\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./property').MultiPropertyDefinition} MultiPropertyDefinition\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./property').SimplePropertyDefinition} SimplePropertyDefinition\n * @typedef {import('./property').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./property').BehaviorMultiPropertyDefinition} BehaviorMultiPropertyDefinition\n * @typedef {import('./property').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./sheet').Root} Root\n * @typedef {import('./types').RootElement} RootElement\n */\n\n\nexport class Bindings {\n  /**\n   * Create bindings for a specific element.\n   * @param {Root} root\n   * @param {RootElement} element\n   */\n  constructor(root, element) {\n    this.root = root;\n    /** @type {RootElement} */\n    this.element = element;\n    /** @type {WeakSet<Declaration>} */\n    this.seen = new WeakSet();\n\n    /** @type {Binding | null} */\n    this.attachTemplate = null;\n    /** @type {MultiBinding<MountedBehaviorType> | null} */\n    this.behavior = null;\n    /** @type {Binding | null} */\n    this.text = null;\n    /** @type {MultiBinding<string> | null} */\n    this.data = null;\n    /** @type {MultiBinding<any[]> | null} */\n    this.each = null;\n    /** @type {MultiBinding<string> | null} */\n    this.event = null;\n    /** @type {MultiBinding<string> | null} */\n    this.attr = null;\n    /** @type {MultiBinding<string> | null} */\n    this.classToggle = null;\n    /** @type {Binding | null} */\n    this.mount = null;\n    /** @type {MultiBinding<string> | null} */\n    this.prop = null;\n    /** @type {Binding | null} */\n    this.storeRoot = null;\n    /** @type {Binding | null} */\n    this.storeSet = null;\n\n    /** @type {Map<string, Binding>} */\n    this.custom = new Map();\n    /** @type {number} */\n    this.flags = 0;\n  }\n\n  /**\n   * Add a declaration to the binding map\n   * @param {Declaration} declaration \n   * @returns \n   */\n  add(declaration) {\n    if(this.seen.has(declaration)) return;\n    this.seen.add(declaration);\n    let propName = declaration.propertyName;\n\n    if(propName in properties) {\n      /** @type {PropertyDefinition} */\n      let defn = properties[propName];\n\n      this.flags |= defn.flag;\n\n      /** @type {MultiPropertyDefinition | ShorthandPropertyDefinition | BehaviorMultiPropertyDefinition | undefined} */\n      let multiDef = undefined;\n      if(defn.feat & features.multi || 'longhand' in defn) {\n        multiDef = /** @type {MultiPropertyDefinition} */(defn);\n      }\n      else if('shorthand' in defn)\n        multiDef = /** @type {ShorthandPropertyDefinition} */(properties[/** @type {LonghandPropertyDefinition} */(defn).shorthand]);\n      if(multiDef) {\n        if(!this[multiDef.prop]) {\n          this[multiDef.prop] = /** @type {MultiBinding<string> & MultiBinding<any[]> & MultiBinding<MountedBehaviorType>} */\n          (new MultiBinding(multiDef, propName, this.root, this.element));\n        }\n\n        let kb = /** @type {MultiBinding<any>} */(this[multiDef.prop]);\n        kb.add(declaration);\n      } else {\n        let binding = this.#getOrAddBinding(\n          propName,\n          /** @type {SimplePropertyDefinition} */(defn)\n        );\n        binding.push(declaration);\n        binding.add(declaration);\n      }\n    } else if(propName.startsWith('--')) {\n      /** @type {Binding} */\n      let binding = this.#getOrAddBinding(propName, null);\n      binding.push(declaration);\n      binding.add(declaration);\n      this.flags |= flags.custom;\n      this.custom.set(propName, binding);\n    }\n  }\n\n  /**\n   * \n   * @param {string} propertyName\n   * @param {SimplePropertyDefinition | null} defn\n   * @returns {Binding}\n   */\n  #getOrAddBinding(propertyName, defn) {\n    let bindingProp = defn ? defn.prop : propertyName;\n    if(!defn) {\n      if(!this.custom.has(propertyName)) {\n        let binding = new Binding(propertyName, this.root, this.element);\n        this.custom.set(propertyName, binding);\n      }\n      return /** @type {Binding} */(this.custom.get(propertyName));\n    } else if(! /** @type {any} */(this)[bindingProp]) {\n      let binding = new SimpleBinding(defn, propertyName, this.root, this.element);\n      /** @type {any} */(this)[bindingProp] = binding;\n    }\n    return /** @type {any} */(this)[bindingProp];\n  }\n}","// @ts-check\nimport { datasetKey } from './custom-prop.js';\n\n/**\n * @typedef {object} FragData\n * @property {any} item\n * @property {number} index\n * \n * @typedef {DocumentFragment & { nodes: Array<ChildNode>; data: FragData }} EachFragment\n * @typedef {import('./types').HostElement} HostElement\n */\n\nexport class EachInstance {\n  /** @type {Map<any, EachFragment>} */\n  keyMap = new Map();\n  /**\n   * @param {HostElement} host \n   * @param {HTMLTemplateElement} template\n   * @param {string} key\n   */\n  constructor(host, template, key) {\n    /** @type {HostElement} */\n    this.host = host;\n    /** @type {HTMLTemplateElement} */\n    this.template = template;\n    /** @type {string} */\n    this.key = key;\n    /** @type {(item: any, index: number) => any} */\n    this.keyFn = this.key ? this.keyKeyed : this.keyNonKeyed;\n\n    let doc = this.host.ownerDocument ?? document;\n\n    /** @type {Comment} */\n    this.start = doc.createComment(`each(items)`)\n    /** @type {Comment} */\n    this.end = doc.createComment(`end each(items)`);\n\n    this.host.append(this.start);\n    this.start.after(this.end);\n\n    /** @type {EachFragment[]} */\n    this.frags = [];\n    /** @type {any[]} */\n    this.keys = [];\n  }\n  /**\n   * \n   * @param {any[]} values\n   */\n  set(values) {\n    return this.updateValues(values);\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @param {*} value \n   * @param {*} index \n   */\n  setData(frag, value, index) {\n    let itemProp = datasetKey('Item');\n    let indexProp = datasetKey('Index');\n    for(let element of frag.nodes) {\n      if('dataset' in element) {\n        /** @type {HTMLElement} */\n        (element).dataset[itemProp] = '';\n        /** @type {any} */\n        (element)[Symbol.for(itemProp)] = value;\n         /** @type {HTMLElement} */\n        (element).dataset[indexProp] = '';\n        /** @type {any} */\n        (element)[Symbol.for(indexProp)] = index;\n      }\n\n    }\n  }\n  /**\n   * \n   * @param {number} index \n   * @param {any} value \n   * @returns \n   */\n  render(index, value) {\n    let doc = this.host.ownerDocument || document;\n    /** @type {EachFragment} */\n    let frag = /** @type {EachFragment} */(doc.importNode(this.template.content, true));\n    frag.nodes = Array.from(frag.childNodes);\n    frag.data = { item: value, index };\n    this.setData(frag, value, index);\n    return frag;\n  }\n  /**\n   * \n   * @param {any} _ \n   * @param {number} index \n   * @returns {any}\n   */\n  keyNonKeyed(_, index) {\n    return index;\n  }\n  /**\n   * \n   * @param {any} value \n   * @returns \n   */\n  keyKeyed(value) {\n    return value[this.key];\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @returns \n   */\n  refrag(frag) {\n    if(!frag.firstChild && frag.nodes)\n      frag.append(...frag.nodes);\n    return frag;\n  }\n  /**\n   * @param {EachFragment} frag\n   * @param {EachFragment} ref\n   */\n  append(frag, ref) {\n    let sibling = ref ? ref.nodes[ref.nodes.length - 1] : this.start;\n    sibling.after(this.refrag(frag));\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @param {EachFragment} ref \n   */\n  before(frag, ref) {\n    let sibling = ref ? ref.nodes[0] : this.end;\n    sibling.before(this.refrag(frag));\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   */\n  remove(frag) {\n    let lastNode = frag.nodes[frag.nodes.length - 1];\n    this.clear(frag.nodes[0], /** @type {Comment} */(lastNode.nextSibling));\n  }\n  clear(startNode = this.start.nextSibling, end = this.end) {\n    /** @type {ChildNode | null} */\n    let node = /** @type {ChildNode} */(startNode);\n    /** @type {ChildNode | null} */\n    let next;\n    while(node !== end) {\n      next = /** @type {ChildNode} */(node).nextSibling;\n      /** @type {ChildNode} */(node).remove();\n      node = next;\n    }\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @param {number} index \n   * @param {any} value \n   * @returns \n   */\n  updateFrag(frag, index, value) {\n    if(frag.data.item !== value || frag.data.index !== index) {\n      this.setData(frag, value, index);\n    }\n    return frag;\n  }\n  /**\n   * \n   * @param {any[]} values\n   */\n  updateValues(values = []) {\n    let invalid = false,\n      /** @type {EachFragment[]} */\n      oldFrags = this.frags,\n      /** @type {EachFragment[]} */\n      newFrags = [],\n      oldKeys = this.keys;\n\n    let expectedMap = new Map();\n    /** @type {any[]} */\n    let newKeys = [];\n    for(let i = 0, len = values.length; i < len; i++) {\n      let key = this.keyFn(values[i], i);\n      expectedMap.set(key, values[i]);\n      newKeys[i] = key;\n    }\n\n    let newHead = 0,\n      newTail = values.length - 1,\n      oldHead = 0,\n      oldTail = oldFrags.length - 1;\n    \n    while(oldHead <= oldTail && newHead <= newTail) {\n      if (oldFrags[oldHead] === null) {\n        oldHead++;\n      } else if (oldFrags[oldTail] === null) {\n        oldTail--;\n      } else if(oldKeys[oldHead] === newKeys[newHead]) {\n        newFrags[newHead] =\n          this.updateFrag(oldFrags[oldHead], newHead, values[newHead]);\n        oldHead++;\n        newHead++;\n      } else if(oldKeys[oldTail] === newKeys[newTail]) {\n        newFrags[newTail] =\n          this.updateFrag(oldFrags[oldTail], newHead, values[newTail]);\n        oldTail--;\n        newTail--;\n      } else if(oldKeys[oldHead] === newKeys[newTail]) {\n        newFrags[newTail] =\n          this.updateFrag(oldFrags[oldHead], newHead, values[newTail]);\n        this.before(oldFrags[oldHead], newFrags[newTail + 1]);\n        oldHead++;\n        newTail--;\n      } else if(oldKeys[oldTail] === newKeys[newHead]) {\n        newFrags[newHead] =\n          this.updateFrag(oldFrags[oldTail], newHead, values[newHead]);\n        this.before(oldFrags[oldTail], oldFrags[oldHead]);\n        oldTail--;\n        newHead++;\n      } else {\n        if(!expectedMap.has(oldKeys[oldHead])) {\n          this.remove(oldFrags[oldHead]);\n          oldHead++;\n        } else if(!expectedMap.has(oldKeys[oldTail])) {\n          this.remove(oldFrags[oldTail]);\n          oldTail--;\n        } else {\n          let value = values[newHead];\n          let frag = this.keyMap.get(this.keyFn(value, newHead));\n          if(frag === undefined) {\n            frag = this.render(newHead, value);\n            this.keyMap.set(this.keyFn(value, newHead), frag);\n          } else {\n            frag = this.updateFrag(frag, newHead, value);\n            // @ts-ignore\n            oldFrags[oldFrags.indexOf(frag)] = null;\n          }\n          newFrags[newHead] = frag;\n          this.append(frag, oldFrags[newHead - 1]);\n          newHead++;\n        }\n      }\n    }\n\n    while(newHead <= newTail) {\n      let frag = this.render(newHead, values[newHead]);\n      this.keyMap.set(this.keyFn(frag.data.item, newHead), frag);\n      this.append(frag, newFrags[newHead - 1]);\n      newFrags[newHead++] = frag;\n      invalid = true;\n    }\n\n    while(oldHead <= oldTail) {\n      let frag = oldFrags[oldHead];\n      this.keyMap.delete(this.keyFn(frag.data.item, oldHead));\n      oldHead++;\n      this.remove(frag);\n      invalid = true;\n    }\n\n    this.keys = newKeys;\n    this.frags = newFrags;\n    return invalid;\n  }\n}","// @ts-check\n\n/**\n * @typedef {import('./sheet').SheetWithValues} SheetWithValues\n * @typedef {Record<string, any>} State \n * @typedef {import('./types').MountedBehavior} MountedBehavior\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n*/\n\n/** @type {Map<string, MountedBehaviorType>} */\nexport let registry = new Map();\n\n/**\n * @typedef {(...args: any[]) => any} CallbackFunction\n * @typedef {(...args: any[]) => Promise<any>} AsyncCallbackFunction\n */\n\n/**\n * \n * @param {Mountpoint} mp \n * @param {CallbackFunction} fn\n * @param {...any[]} args\n * @returns {any}\n */\nfunction scopedCallback(mp, fn, ...args) {\n  let res = fn.call(mp.behavior, ...args);\n  mp.update();\n  return res;\n}\n\n/**\n * \n * @param {Mountpoint} mp \n */\nexport function BehaviorContext(mp) {\n  /** @type {Element | Document | ShadowRoot} */\n  this.element = mp.rootElement;\n  /** @type {() => void} */\n  this.rebind = mp.update.bind(mp);\n  /** @type {Map<string, Map<string, any>>} */\n  this.stores = new Map();\n}\n\nexport class Mountpoint {\n  /**\n   * \n   * @param {HTMLElement | Document | ShadowRoot} rootElement \n   * @param {MountedBehaviorType} Behavior \n   * @param {Map<string, any> | undefined} props\n   */\n  constructor(rootElement, Behavior, props) {\n    /** @type {HTMLElement | Document | ShadowRoot} */\n    this.rootElement = rootElement;\n    /** @type {Map<string, any> | null} */\n    this.props = props || null;\n    /** @type {BehaviorContext} */\n    this.context = new BehaviorContext(this);\n    /** @type {MountedBehavior} */\n    this.behavior = new Behavior(/** @type {never} */(props), this.context);\n    /** @type {SheetWithValues | null} */\n    this.bindings = null;\n    /** @type {WeakMap<CallbackFunction, CallbackFunction>} */\n    this.callbacks = new WeakMap();\n    /** @type {Mountpoint | null} */\n    this.parent = null;\n  }\n  /**\n   * \n   * @param {(...args: any[]) => any} callbackFn \n   * @returns {CallbackFunction}\n   */\n  getCallback(callbackFn) {\n    if(this.callbacks.has(callbackFn))\n      return /** @type {CallbackFunction} */(this.callbacks.get(callbackFn));\n    let listener = scopedCallback.bind(null, this, callbackFn);\n    this.callbacks.set(callbackFn, listener);\n    return listener;\n  }\n  /**\n   * @returns {boolean}\n   */\n  update() {\n    this.bindings = this.behavior.bind(this.props, this.context);\n    return this.bindings.update(this);\n  }\n\n  unmount() {\n    if(this.bindings)\n      this.bindings.unmount(this);\n  }\n}\n\n/**\n * \n * @param {HTMLElement | Document | ShadowRoot} element \n * @param {MountedBehaviorType} behavior\n * @param {Map<string, any>} [props]\n * @returns {Mountpoint}\n */\nexport function mount(element, behavior, props) {\n  let mp = new Mountpoint(element, behavior, props);\n  mp.update();\n  return mp;\n}\n\n/**\n * \n * @param {string} name \n * @param {MountedBehaviorType} behavior\n * @returns {void} \n */\nexport function registerBehavior(name, behavior) {\n  registry.set(name, behavior);\n}","// @ts-check\n\nimport { flags } from './property.js';\nimport { EachInstance } from './each.js';\nimport { datasetPropKey } from './custom-prop.js';\nimport { Mountpoint } from './mount.js';\nimport { lookup } from './scope.js';\nimport { storePropName, storeDataName, storeDataPropName, Store } from './store.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./bindings').Bindings} Bindings\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./multi-binding').MultiBinding<string>} KeyedMultiBinding\n * @typedef {import('./multi-binding').MultiBinding<any[]>} ArrayMultiBinding\n * @typedef {import('./multi-binding').MultiBinding<MountedBehaviorType>} BehaviorMultiBinding\n * @typedef {import('./sheet').Root} Root\n * @typedef {import('./types').HostElement} HostElement\n */\n\n/** @type {WeakMap<HostElement, EachInstance>} */\nconst eachInstances = new WeakMap();\n\n/** @type {WeakMap<HostElement, Map<MountedBehaviorType, Mountpoint>>} */\nconst mountPoints = new WeakMap();\n\n/**\n * \n * @param {HostElement} element \n * @param {Bindings} bindings \n * @param {Root} root\n * @param {Changeset} changeset\n * @returns {boolean}\n */\nfunction render(element, bindings, root, changeset) {\n  let invalid = false;\n  let bflags = bindings.flags;\n\n  if(bflags & flags.storeRoot) {\n    if(!(element instanceof HTMLElement)) {\n      throw new Error('Stores cannot be used on non-HTML elements.');\n    }\n\n    let binding = /** @type {Binding} */(bindings.storeRoot);\n    if(binding.dirty(changeset)) {\n      let oldValue = binding.value;\n      let storeName = binding.update(changeset);\n      if(storeName) {\n        element.dataset[storeDataPropName(storeName)] = '';\n        let map = new Store(root);\n        /** @type {any} */\n        (element)[Symbol.for(storePropName(storeName))] = map;\n        root.mount?.context?.stores.set(storeName, map);\n      } else {\n        delete element.dataset[storeDataPropName(oldValue)];\n        delete /** @type {any} */(element)[Symbol.for(storePropName(oldValue))];\n        root.mount?.context?.stores.delete(oldValue);\n      }\n      invalid = true;\n    }\n  }\n\n  if(bflags & flags.custom) {\n    if(!(element instanceof HTMLElement)) {\n      throw new Error('Custom properties cannot be used on non-HTML elements.');\n    }\n\n    for(let [propertyName, binding] of bindings.custom) {\n      if(binding.dirty(changeset)) {\n        binding.update(changeset);\n        let value = binding.getList();\n        element.dataset[datasetPropKey(propertyName)] = '';\n        /** @type {any} */\n        (element)[Symbol.for(propertyName)] = {\n          value,\n          compute: binding.compute\n        };\n      }\n    }\n  }\n\n  if(bflags & flags.storeSet) {\n    let binding = /** @type {Binding} */(bindings.storeSet);\n    if(binding.dirty(changeset)) {\n      let args = binding.update(changeset);\n      if(args) {\n        let [storeName, key, value] = args;\n        let dataName = storeDataName(storeName);\n        let map = lookup(element, dataName, `[${dataName}]`, storePropName(storeName));\n        map?.set(key, value);\n      }\n      invalid = true;\n    }\n  }\n\n  if(bindings.flags & flags.classToggle && 'classList' in element) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.classToggle);\n    for(let [className, toggle] of binding.changes(changeset)) {\n      element.classList.toggle(className, toggle);\n      invalid = true;\n    }\n  }\n\n  if(bflags & flags.each) {\n    let binding = /** @type {ArrayMultiBinding} */(bindings.each);\n    for(let [items, template, key] of binding.values(changeset)) {\n      /** @type {EachInstance | undefined} */\n      let inst;\n      if(eachInstances.has(element)) {\n        inst = /** @type {EachInstance} */(eachInstances.get(element));\n      }\n\n      if(!inst || inst.template !== template) {\n        inst = new EachInstance(element, template, key);\n        eachInstances.set(element, inst);\n      }\n      if(inst.set(items)) invalid = true;\n    }\n  }\n\n  attach: if(bflags & flags.attach) {\n    let binding = /** @type {Binding} */(bindings.attachTemplate);\n    if(binding.dirty(changeset)) {\n      /** @type {HTMLTemplateElement} */\n      let result = binding.update(changeset);\n      if(Array.isArray(result)) result = result[0];\n      if(result === undefined) break attach;\n      let doc = element.ownerDocument || document;\n      let frag = doc.importNode(result.content, true);\n      element.replaceChildren(frag);\n      invalid = true;\n      changeset.flags |= flags.attach;\n    }\n  }\n\n  if(bflags & flags.attr && element instanceof Element) {\n    for(let [key, value, toggle] of /** @type {KeyedMultiBinding} */(bindings.attr).changes(changeset)) {\n      if(toggle)\n        element.setAttribute(key, value);\n      else\n        element.removeAttribute(key);\n      invalid = true;\n    }\n  }\n\n  if(bflags & flags.data) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.data);\n    for(let [prop, value] of binding.changes(changeset)) {\n      if(value === undefined)\n        delete /** @type {HTMLElement} */\n        (element).dataset[prop];\n      else\n        /** @type {HTMLElement} */\n        (element).dataset[prop] = value;\n\n      invalid = true;\n    }\n  }\n\n  text: if(bflags & flags.text) {\n    let binding = /** @type {Binding} */(bindings.text);\n    if(binding.dirty(changeset)) {\n      let values = binding.update(changeset);\n      if(changeset.flags & flags.attach) break text;\n      if(Array.isArray(values)) values = values.join('');\n      element.textContent = values;\n    }\n  }\n\n  if(bflags & flags.prop) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.prop);\n    for(let [key, value] of binding.changes(changeset)) {\n      /** @type {any} */(element)[key] = value;\n    }\n  }\n\n  if(bflags & flags.behavior) {\n    let binding = /** @type {BehaviorMultiBinding} */(bindings.behavior);\n    for(let [Behavior, props, OldBehavior] of binding.changes(changeset)) {\n      let hasOldValue = OldBehavior !== undefined;\n      let sameBehavior = hasOldValue && OldBehavior === Behavior;\n\n      /** @type {Map<MountedBehaviorType, Mountpoint>} */\n      let map;\n      if(mountPoints.has(element))\n        map = /** @type {Map<MountedBehaviorType, Mountpoint>} */(mountPoints.get(element));\n      else {\n        map = new Map();\n        mountPoints.set(element, map);\n      }\n\n      if(hasOldValue || sameBehavior) {\n        let mp = /** @type {Mountpoint} */(map.get(OldBehavior));\n        if(sameBehavior) {\n          if(mp.update()) invalid = true;\n        }\n        else mp.unmount();\n      }\n      if(!sameBehavior && Behavior !== null) {\n        let mountpoint = new Mountpoint(/** @type {HTMLElement} */(element), Behavior, props);\n        mountpoint.parent = root.mount;\n        if(mountpoint.update()) invalid = true;\n        map.set(Behavior, mountpoint);\n      }\n    }\n  }\n\n  // Events last, does not affect the cascade.\n  if(bflags & flags.event) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.event);\n    for(let [eventName, listener, capture, once, passive, signal, _oldEventName, oldListener, oldCapture] of binding.changes(changeset)) {\n      if(oldListener !== undefined)\n        element.removeEventListener(eventName, root.getCallback(oldListener), oldCapture);\n      if(listener)\n        element.addEventListener(eventName, root.getCallback(listener), {\n          capture,\n          once,\n          passive,\n          signal\n        });\n    }\n  }\n\n  return invalid;\n}\n\n/**\n * @param {Map<Element | ShadowRoot | Document, Bindings>} allBindings\n * @param {Root} root\n * @param {Changeset} changeset\n * @returns {boolean}\n */\nexport function renderRoot(allBindings, root, changeset) {\n  let invalid = false;\n  for(let [element, bindings] of allBindings) {\n    if(render(element, bindings, root, changeset))\n      invalid = true;\n  }\n  return invalid;\n}\n\n/**\n * \n * @param {HostElement} element \n * @param {Bindings} bindings \n * @param {Root} root\n */\nfunction unmount(element, bindings, root) {\n  let bflags = bindings.flags;\n  if(bflags & flags.behavior) {\n    let binding = /** @type {BehaviorMultiBinding} */(bindings.behavior);\n    let map = /** @type {Map<MountedBehaviorType, Mountpoint>} */(mountPoints.get(element));\n    for(let [OldBehavior] of binding.current()) {\n      map.get(OldBehavior)?.unmount();\n    }\n    // TODO allow multiple\n    ///** @type {Mountpoint} */(mountPoints.get(element)).unmount();\n  }\n\n  if(bflags & flags.event) {\n    let eventBinding = /** @type {KeyedMultiBinding} */(bindings.event);\n    for(let [_key, eventName, listener] of eventBinding.current()) {\n      element.removeEventListener(eventName, root.getCallback(listener));\n    }\n  }\n}\n\n/**\n * @param {Map<HostElement, Bindings>} allBindings\n * @param {Root} root\n */\nexport function unmountRoot(allBindings, root) {\n  for(let [element, bindings] of allBindings) {\n    unmount(element, bindings, root);\n  }\n}","// @ts-check\n\nexport class Changeset {\n  /**\n   * \n   * @param {any[]} values \n   */\n  constructor(values) {\n    /** @type {any[]} */\n    this.values = values;\n    /** @type {boolean} */\n    this.selectors = true;\n    /** @type {number} */\n    this.flags = 0;\n  }\n}","// @ts-check\nimport { Bindings } from './bindings.js';\nimport { renderRoot, unmountRoot } from './render.js';\nimport { Changeset } from './changeset.js';\nimport { Mountpoint } from './mount.js';\n\n/**\n * @typedef {import('./types').HostElement} HostElement\n * @typedef {import('./types').RootElement} RootElement\n */\n\n/**\n * \n * @param {Function} a \n * @returns {Function}\n */\nconst identity = (a) => a;\n\n/**\n * @typedef {import('./rule').Rule} Rule\n */\n\nexport class Root {\n  /**\n   * @param {RootElement | Mountpoint} rootElement \n   * @param {BindingSheet} sheet \n   */\n  constructor(rootElement, sheet) {\n    /** @type {Mountpoint | null} */\n    this.mount = (rootElement instanceof Mountpoint) ? rootElement : null;\n    /** @type {RootElement} */\n    this.rootElement = this.mount ? this.mount.rootElement :\n      /** @type {HTMLElement} */(rootElement);\n    /** @type {Rule[]} */\n    this.rules = sheet.rules;\n    /** @type {Map<HostElement, Bindings>} */\n    this.bindingMap = new Map();\n    /** @type {(a: () => any) => any} */\n    this.getCallback = this.mount ? this.mount.getCallback.bind(this.mount) : identity;\n    /** @type {any[]} */\n    this.values = /** @type {any[]} */(/** @type {unknown} */(null));\n    /** @type {number} */\n    this.queue = 0;\n  }\n  /**\n   * @param {any[]} values\n   * @returns {boolean}\n   */\n  update(values = this.values) {\n    this.values = values;\n    this.queue++;\n    if(this.queue > 1) return false;\n    let invalid = true;\n    let changed = false;\n    while(invalid) {\n      let changeset = new Changeset(values);\n      this.collect();\n      invalid = renderRoot(this.bindingMap, this, changeset);\n      if(invalid) changed = true;\n    }\n    if(changed) {\n      this.mount?.parent?.update();\n    }\n    this.queue = 0;\n    return changed;\n  }\n  /**\n   * Collect all of the bindings\n   */\n  collect() {\n    let rootElement = this.rootElement;\n    for(let rule of this.rules) {\n      for(let el of rule.querySelectorAll(rootElement)) {\n        /** @type {Bindings} */\n        let bindings;\n        if(this.bindingMap.has(el)) {\n          bindings = /** @type {Bindings} */(this.bindingMap.get(el));\n        } else {\n          bindings = new Bindings(this, el);\n          this.bindingMap.set(el, bindings);\n        }\n        for(let declaration of rule.declarations) {\n          bindings.add(declaration);\n        }\n      }\n    }\n  }\n  unmount() {\n    unmountRoot(this.bindingMap, this);\n  }\n}\n\nexport class BindingSheet {\n  constructor() {\n    /** @type {Rule[]} */\n    this.rules = [];\n  }\n  /**\n   * Add a rule to this sheet\n   * @param {Rule} rule \n   */\n  addRule(rule) {\n    this.rules.push(rule);\n  }\n}\n\nexport class SheetWithValues {\n  /**\n   * @param {BindingSheet} sheet\n   * @param {any[]} values\n   */\n  constructor(sheet, values) {\n    /** @type {WeakMap<Element | Mountpoint, Root>} */\n    this.roots = new WeakMap();\n    this.sheet = sheet;\n    this.values = values;\n  }\n\n  /**\n   * @param {HTMLElement | Mountpoint} rootElement\n   * @returns {boolean}\n   */\n  update(rootElement) {\n    /** @type {Root} */\n    let root;\n    if(this.roots.has(rootElement)) {\n      root = /** @type {Root} */(this.roots.get(rootElement));\n    } else {\n      root = new Root(rootElement, this.sheet);\n      this.roots.set(rootElement, root);\n    }\n    return root.update(this.values);\n  }\n  /**\n   * \n   * @param {Element | Mountpoint} rootElement \n   */\n  unmount(rootElement) {\n    if(this.roots.has(rootElement)) {\n      let root = /** @type {Root} */(this.roots.get(rootElement));\n      root.unmount();\n    }\n  }\n}","// @ts-check\n\nimport { anyValue, NO_VALUE } from './value.js';\nimport { createValueTemplate } from './template.js';\nimport { ComputedValue } from './compute.js';\nimport { registry as behaviorRegistry } from './mount.js';\nimport { lookup } from './scope.js';\nimport { storeDataName, storePropName, getKeySymbol } from './store.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./fn').ICorsetFunction} ICorsetFunction\n * @typedef {import('./fn').ICorsetFunctionClass} ICorsetFunctionClass\n * @typedef {import('./fn').FunctionContext} FunctionContext\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n */\n\n/**\n * @typedef {Object} FunctionRegistry - Some explanation of what this is.\n * @property {Map<string, ICorsetFunctionClass>} fns\n */\n\nconst RegistryBase = {};\n\n/**\n * @returns {FunctionRegistry}\n */\nfunction createRegistry() {\n  return Object.create(RegistryBase, {\n    fns: {\n      enumerable: true,\n      value: new Map()\n    }\n  });\n}\n\nexport const registry = createRegistry();\nexport const localsRegistry = createRegistry();\n\n/**\n * \n * @this {FunctionRegistry}\n * @param {string} name \n * @param {ICorsetFunctionClass} ctr \n */\nfunction registerFunction(name, ctr) {\n  this.fns.set(name, ctr);\n}\n\n/**\n * \n * @this {FunctionRegistry | void}\n * @param {string} name \n * @param {ICorsetFunctionClass} ctr \n */\nexport function registerCustomFunction(name, ctr) {\n  if(!name.startsWith('--')) {\n    throw new Error(`Custom functions must start with --`);\n  }\n  let reg = this;\n  if(!reg || !RegistryBase.isPrototypeOf(reg)) {\n    reg = registry;\n  }\n  registerFunction.call(reg, name, ctr);\n}\n\nregisterFunction.call(registry, 'get', class {\n  constructor() {\n    this.value = NO_VALUE;\n  }\n  /**\n   *\n   * @param {[{[key: string | symbol]: any}, CallbackOrProp]} args\n   * @returns\n   */\n  check([value, callbackOrProp]) {\n    if(typeof value === 'object') {\n      if(typeof callbackOrProp !== 'function') {\n        let newValue = getKeySymbol in value ?\n          value[getKeySymbol](callbackOrProp) :\n          value[callbackOrProp];\n        if(newValue !== this.value) {\n          this.value = newValue;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * \n   * @typedef {((o: {}) => any) | string} CallbackOrProp\n   * \n   * @param {[{[key: string | symbol]: any}, CallbackOrProp]} args\n   * @returns {any}\n   */\n  call([value, callbackOrProp]) {\n    if(typeof callbackOrProp === 'function') {\n      return callbackOrProp(value);\n    } else if(getKeySymbol in value) {\n      return value[getKeySymbol](callbackOrProp);\n    } else {\n      return value[callbackOrProp];\n    }\n  }\n});\n\nregisterFunction.call(registry, 'select', class {\n  /**\n   * \n   * @param {[string]} param0\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} ctx \n   */\n  call([selector], _props, { rootElement }) {\n    return rootElement.querySelector(selector);\n  }\n});\n\nclass ScopeLookupFunction {\n  /**\n   * Look up a value within the DOM scope\n   * @param {string} dataName\n   * @param {string} propName\n   */\n   constructor(dataName, propName) {\n    /** @type {string} */\n    this.dataPropName = 'data-corset-' + dataName;\n    /** @type {string} */\n    this.dataSelector = '[' + this.dataPropName + ']';\n    /** @type {string} */\n    this.propName = propName;\n    /** @type {any} */\n    this.value = NO_VALUE;\n  }\n  /**\n   * \n   * @param {any[]} param0\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  check([], _props, { element }, changeset) {\n    let check = false;\n    if(changeset.selectors) check = true;\n    if(check) {\n      let value = lookup(element, this.dataPropName, this.dataSelector, this.propName);\n      if(value !== this.value) {\n        this.value = value;\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * \n   * @returns {any}\n   */\n  call() {\n    return this.value;\n  }\n}\n\nregisterFunction.call(registry, 'item', class extends ScopeLookupFunction {\n  constructor() {\n    super('item', 'corsetItem');\n  }\n});\n\nregisterFunction.call(registry, 'index', class extends ScopeLookupFunction {\n  constructor() {\n    super('index', 'corsetIndex');\n  }\n});\n\nregisterFunction.call(registry, 'store-get', class {\n  constructor() {\n    /** @type {any} */\n    this.value = undefined;\n  }\n  /**\n   * \n   * @param {[string, string]} _args\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  check([storeName, key], _props, { element }, changeset) {\n    let check = changeset.selectors;\n    if(check) {\n      let dataName = storeDataName(storeName);\n      /** @type {Map<string, any> | undefined} */\n      let map = lookup(element, dataName, `[${dataName}]`, storePropName(storeName));\n      if(map?.get(key) !== this.value) {\n        this.value = map?.get(key);\n        return true;\n      }\n    }\n    return false;\n  }\n  call() {\n    return this.value;\n  }\n});\n\nregisterFunction.call(registry, 'store', class {\n  constructor() {\n    /** @type {Map<any, any> | undefined} */\n    this.map = undefined;\n  }\n  /**\n   * \n   * @param {[string]} _args\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n   check([storeName], _props, { element }, changeset) {\n    let check = changeset.selectors;\n    if(check) {\n      let dataName = storeDataName(storeName);\n      /** @type {Map<any, any> | undefined} */\n      let map = lookup(element, dataName, `[${dataName}]`, storePropName(storeName));\n      if(map !== this.map) {\n        this.map = map;\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @returns {Map<any, any> | undefined}\n   */\n  call() {\n    return this.map;\n  }\n});\n\nregisterFunction.call(registry, 'bind', class {\n  /**\n   * \n   * @param {[Function, ...any[]]} param0\n   * @returns \n   */\n  call([fn, ...boundArgs]) {\n    /**\n     * @this {MountedBehaviorType | Element}\n     * @param {...any[]} callArgs\n     * @returns {(...args: any[]) => any}\n     */\n    function boundFn(...callArgs) {\n      return fn.call(this, ...boundArgs, ...callArgs);\n    }\n    Object.defineProperty(boundFn, 'name', {\n      value: 'bound ' + fn.name\n    });\n    return boundFn;\n  }\n});\n\nregisterFunction.call(registry, 'data', class {\n  /**\n   * \n   * @param {[string]} param0 \n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   */\n  call([prop], _props, { element }) {\n    if(!(element instanceof HTMLElement))\n      throw new Error(`data() only works on HTMLElements.`);\n    return /** @type {HTMLElement} */(element).dataset[prop];\n  }\n});\n\n/**\n * @typedef {Readonly<[MountedBehaviorType, Map<string, any> | null]>} MountValue\n */\n\nregisterFunction.call(registry, 'mount', class {\n  constructor() {\n    /** @type {ComputedValue | null} */\n    this.compute = null;\n    /** @type {MountedBehaviorType | null} */\n    this.Behavior = null;\n    /** @type {MountValue | null} */\n    this.value = null;\n  }\n  /**\n   *\n   * @param {[MountedBehaviorType | string]} param0\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} context\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  check([Ctr], _props, context, changeset) {\n    /** @type {MountedBehaviorType} */\n    let Behavior = /** @type {MountedBehaviorType} */(Ctr);\n    if(typeof Ctr === 'string') {\n      let name = Ctr;\n      if(!behaviorRegistry.has(name))\n        throw new Error(`Unregistered behavior ${name}`);\n      Behavior = /** @type {MountedBehaviorType} */(behaviorRegistry.get(name));\n    }\n\n    if(Behavior !== this.Behavior) {\n      let ValueType = anyValue(Behavior);\n      ValueType.inputProperties = Behavior.inputProperties;\n      let template = createValueTemplate(ValueType);\n      this.Behavior = Behavior;\n      this.compute = new ComputedValue(\n        template,\n        // A FunctionContext's prototype is actually a Binding at runtime.\n        // If this ever changes, the following will be a wrong cast.\n        /** @type {Binding} */(Object.getPrototypeOf(context))\n      );\n      this.compute.check(changeset);\n      this.value = /** @type {MountValue} */\n        (Object.freeze([Behavior, this.compute.inputProps]));\n      return true;\n    } else if(this.compute) {\n      let dirty = this.compute.dirty(changeset);\n      this.compute.check(changeset);\n      return dirty;\n    }\n    return false;\n  }\n  /**\n   *\n   * @param {[]} param0\n   */\n  call([]) {\n    return this.value;\n  }\n});\n\n/**\n * \n * @param {string} propName \n * @returns {ICorsetFunctionClass}\n */\nexport function createLocalsScopeFunction(propName) {\n  /** @type {ICorsetFunctionClass} */\n  class ScopeLookupFunction {\n    static inputProperties = [propName];\n    /**\n     * \n     * @param {any[]} args \n     * @param {Map<typeof propName, any>} props\n     * @param {FunctionContext} context \n     */\n    call(args, props, context) {\n      /** @type {((...args: any[]) => any) | undefined} */\n      let fn = props.get(propName);\n      if(typeof fn !== 'function') {\n        throw new Error(`Unable to find the custom function ${propName}`);\n      }\n      return fn.apply(context, args);\n    }\n  }\n\n  registerCustomFunction.call(localsRegistry, propName, ScopeLookupFunction);\n  return ScopeLookupFunction;\n}","// @ts-check\n\n/**\n * @typedef {import('./parser').RawStringTemplate} RawStringTemplate\n */\n\n import {\n  heap8,\n  heap32, mem32,\n  parse, next,\n  readNumberOfValues,\n  readFirstValuePointer,\n  readProperty,\n  readString\n} from './parser.js';\nimport { Declaration } from './declaration.js';\nimport { Rule } from './rule.js';\nimport { BindingSheet, SheetWithValues } from './sheet.js';\nimport {\n  anyValue,\n  CommaSeparatedListValue,\n  functionValue,\n  InsertionValue,\n  PlaceholderValue,\n  SpaceSeparatedListValue,\n} from './value.js';\nimport {\n  registry as fnRegistry,\n  localsRegistry as fnLocalsRegistry,\n  createLocalsScopeFunction\n} from './function.js';\nimport { properties, features } from './property.js';\nimport { createValueTemplate } from './template.js';\nimport { Name, KEYWORD_REVERT_SHEET, KEYWORD_ALL } from './constants.js';\n\n/**\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./types').ValueType} ValueType\n * @typedef {import('./types').Value} Value\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * @typedef {import('./function').ICorsetFunctionClass} ICorsetFunctionClass\n */\n\nlet keywordMap = new Map([\n  [3, KEYWORD_REVERT_SHEET],\n  [4, KEYWORD_ALL]\n]);\n\n/**\n * Gets the value at the pointer location.\n * @param {Number} ptr\n * @returns {ValueTemplate}\n */\nfunction getValue(ptr) {\n  let ptr32 = ptr >> 2;\n  let ptrv32 = ptr32 + 3;\n  \n  let valueType = mem32[ptr32];\n  switch(valueType) {\n    case 1: {\n      return createValueTemplate(InsertionValue, [\n        createValueTemplate(anyValue(mem32[ptrv32]))\n      ]);\n    }\n    case 2:\n    case 3: {\n      return createValueTemplate(\n        anyValue(readString(mem32[ptrv32], mem32[ptrv32 + 1]))\n      );\n    }\n    case 4: {\n      let fnName = readString(mem32[ptrv32], mem32[ptrv32 + 1]);\n      /** @type {ValueType} */\n      let Value;\n      switch(true) {\n        case fnName === 'var': Value = PlaceholderValue; break;\n        case fnRegistry.fns.has(fnName): {\n          let CorsetFunction = /** @type {ICorsetFunctionClass} */(fnRegistry.fns.get(fnName));\n          Value = functionValue(CorsetFunction);\n          break;\n        }\n        case fnLocalsRegistry.fns.has(fnName): {\n          let CorsetFunction = /** @type {ICorsetFunctionClass} */(fnLocalsRegistry.fns.get(fnName));\n          Value = functionValue(CorsetFunction);\n          break;\n        }\n        case fnName.startsWith('--'): {\n          let CorsetFunction = createLocalsScopeFunction(fnName);\n          Value = functionValue(CorsetFunction);\n          break;\n        }\n        default: throw new Error(`Unknown function ${fnName}`);\n      }\n\n      let args = [];\n      let vptr = mem32[ptrv32 + 3];\n      while(vptr) {\n        args.push(getValue(vptr));\n        vptr = mem32[(vptr >> 2) + 1];\n      }\n\n      return createValueTemplate(Value, args);\n    }\n    case 6: {\n      return createValueTemplate(anyValue(Boolean(mem32[ptrv32])));\n    }\n    case 7: {\n      return createValueTemplate(anyValue(Name.for(readString(mem32[ptrv32], mem32[ptrv32 + 1]))))\n    }\n    case 8: {\n      return createValueTemplate(anyValue(keywordMap.get(mem32[ptrv32])));\n    }\n    default: {\n      throw new Error(`Unknown value type [${valueType}]`);\n    }\n  }\n}\n\n/**\n * \n * @param {RawStringTemplate} strings \n * @param {any[]} values \n * @returns \n */\nfunction compile(strings, values) {\n  let sheet = new BindingSheet();\n  let sourceOrder = 0;\n  let rule;\n  parse(strings, values);\n  while(next()) {\n    switch(heap8[0]) {\n      case 1: {\n        rule = new Rule(readString(heap32[1], heap32[2]));\n        sheet.addRule(rule);\n        break;\n      }\n      case 2: {\n        let propName = readProperty();\n\n        let ptr = readFirstValuePointer();\n        let num = readNumberOfValues();\n\n        /** @type {PropertyDefinition} */\n        let defn = properties[propName];\n\n        /** @type {ValueTemplate[]} */\n        let args = [], _args = args;\n        while(ptr) {\n          let valueType = mem32[ptr >> 2];\n          switch(valueType) {\n            case 5: {\n              if(args === _args) {\n                args = [];\n              }\n              args.push(createValueTemplate(SpaceSeparatedListValue, _args));\n              _args = [];\n              break;\n            }\n            default: {\n              _args.push(getValue(ptr));\n              break;\n            }\n          }\n          ptr = mem32[(ptr >> 2) + 1];\n        }\n        let commaSeparated = args !== _args;\n        // Multis are coerced to comma separated even if they had no commas.\n        // Ideally this would happen in the parser.\n        if(defn?.feat & features.multi && !commaSeparated) {\n          args = [];\n        }\n        if(commaSeparated || ((defn?.feat & features.multi))) {\n          args.push(createValueTemplate(SpaceSeparatedListValue, _args));\n        }\n\n        //let declaration = new Declaration(/** @type {Rule} */(rule), propName, sourceOrder++);\n        /** @type {ValueTemplate} */\n        let template;\n        switch(true) {\n          case !!(defn?.feat & features.multi): {\n            template = createValueTemplate(CommaSeparatedListValue, args);\n            break;\n          }\n          case !!(defn?.feat & features.longhand) || num > 1: {\n            let Value = commaSeparated ? CommaSeparatedListValue : SpaceSeparatedListValue;\n            template = createValueTemplate(Value, args);\n            break;\n          }\n          default: {\n            template = args[0];\n            break;\n          }\n        }\n\n        let declaration = new Declaration(/** @type {Rule} */(rule), propName, sourceOrder++, template);\n\n        declaration.init();\n        /** @type {Rule} */(rule).addDeclaration(declaration);\n\n        break;\n      }\n      // TODO remove in build\n      case 4: {\n        let code = heap32[1];\n        switch(code) {\n          case 1:\n          case 2: {\n            let charCode = heap32[2];\n            switch(charCode) {\n              // '\n              case 39: {\n                throw new SyntaxError(\"Saw the a single quote character ('). Use double quotes (\\\") for strings.\")\n              }\n              default: {\n                throw new SyntaxError(`Unexpected token \"${String.fromCharCode(charCode)}\" found. Error code ${code}.`);\n              }\n            }\n            \n          }\n          default: {\n            throw new Error(`Unknown Parse error occurred. Error code [${code}]`);\n          }\n        }\n      }\n    }\n  }\n  return sheet;\n}\n\nconst cache = new WeakMap();\n\n/**\n * \n * @param {RawStringTemplate} strings \n * @param {any[]} values \n * @returns {SheetWithValues}\n */\nfunction memoizeCompile(strings, values) {\n  if(cache.has(strings)) {\n    return cache.get(strings);\n  }\n  let bindingSheet = compile(strings, values);\n  let sheet = new SheetWithValues(bindingSheet, values);\n  cache.set(strings, sheet);\n  return sheet;\n}\n\n/**\n * The main DSL\n * @param {RawStringTemplate} strings \n * @param  {...any} values \n * @returns {SheetWithValues}\n */\nexport function sheet(strings, ...values) {\n  let sheet = memoizeCompile(strings, values);\n  sheet.values = values;\n  return sheet;\n}"],"names":["exports","WebAssembly","instantiateStreaming","fetch","URL","import","meta","url","toString","instance","$get_tag","get_tag","$memory","memory","$parse","parse","$reset","reset","mem8","Uint8Array","buffer","mem32","Uint32Array","heap8","heap32","data8","enc","TextEncoder","dec","TextDecoder","readFromBuffer","start","end","decode","slice","len","readString","properties","flag","feat","prop","read","el","tmpl","ownerDocument","document","createElement","content","append","Array","from","childNodes","attr","features","longhand","defaults","shorthand","index","default","key","getAttribute","hasAttribute","classList","contains","data","Error","dataset","each","event","undefined","behavior","text","textContent","Declaration","constructor","rule","propertyName","sourceOrder","template","this","keyTemplate","flags","init","defn","multi","label","rootSelect","querySelect","querySelectorAll","selector","Rule","declarations","specificity","addDeclaration","declaration","push","lookup","element","dataPropName","dataSelector","propName","Symbol","for","closest","pascalCase","replace","_whole","letter","toUpperCase","datasetKey","datasetPropKey","getKeySymbol","Store","Map","root","updateMount","super","Object","_classPrivateFieldLooseBase","mount","update","bind","Function","prototype","get","set","k","v","storePropName","storeName","storeDataName","storeDataPropName","NO_VALUE","anyValue","value","InsertionValue","current","check","_binding","_props","values","SpaceSeparatedListValue","CommaSeparatedListValue","PlaceholderValue","compute","args","binding","changeset","selectors","dirty","scope","length","functionValue","CorsetFunction","callValue","call","FunctionValue","context","create","createStore","fn","props","inputProperties","checkValue","ComputedValue","WeakMap","argDeps","inputDeps","inputProps","raw","Value","dep","deps","hydrate","listValue","calculate","has","method","isArray","compare","d1","d2","Binding","rootElement","computedValues","initial","add","addTemplate","sorted","item","comparator","low","high","mid","splice","binaryInsert","getList","hasValue","walk","i","matches","ConstantMethods","map","is","isPrototypeOf","base","createConstant","ConstantBase","name","enumerable","writable","configurable","assign","Name","Keyword","KEYWORD_REVERT_SHEET","KEYWORD_ALL","SparseArray","fill","numberOfValues","empty","full","createValueTemplate","MultiBinding","numberOfValuesWithKey","active","Set","oldValues","declFlags","unset","valueMap","getValueList","numOfValues","valueList","dirtyKeys","loop","computedValue","idx","val","isName","Behavior","allValues","keyed","propValue","delete","hasLabel","initialValues","valuesWithKey","out","concat","changes","type","freeze","keyIsName","d","SimpleBinding","Bindings","seen","WeakSet","attachTemplate","classToggle","storeRoot","storeSet","custom","multiDef","startsWith","bindingProp","EachInstance","host","keyMap","keyFn","keyKeyed","keyNonKeyed","doc","createComment","after","frags","keys","updateValues","setData","frag","itemProp","indexProp","nodes","render","importNode","_","refrag","firstChild","ref","before","remove","clear","nextSibling","startNode","next","node","updateFrag","invalid","oldFrags","newFrags","oldKeys","expectedMap","newKeys","newHead","newTail","oldHead","oldTail","indexOf","registry","scopedCallback","mp","res","BehaviorContext","rebind","stores","Mountpoint","bindings","callbacks","parent","getCallback","callbackFn","listener","unmount","registerBehavior","eachInstances","mountPoints","bflags","HTMLElement","oldValue","dataName","className","toggle","items","inst","attach","result","replaceChildren","Element","setAttribute","removeAttribute","join","OldBehavior","hasOldValue","sameBehavior","mountpoint","eventName","capture","once","passive","signal","_oldEventName","oldListener","oldCapture","removeEventListener","addEventListener","renderRoot","allBindings","eventBinding","_key","Changeset","identity","a","Root","sheet","rules","bindingMap","queue","changed","collect","unmountRoot","BindingSheet","addRule","SheetWithValues","roots","RegistryBase","createRegistry","fns","localsRegistry","registerFunction","ctr","registerCustomFunction","reg","callbackOrProp","newValue","querySelector","ScopeLookupFunction","boundArgs","boundFn","callArgs","defineProperty","Ctr","behaviorRegistry","ValueType","getPrototypeOf","keywordMap","getValue","ptr","ptr32","ptrv32","valueType","fnName","fnRegistry","fnLocalsRegistry","apply","createLocalsScopeFunction","vptr","Boolean","cache","strings","bindingSheet","source","holes","String","bytes","encode","byteLength","dataPtr","subarray","tagPtr","num","_args","commaSeparated","code","charCode","SyntaxError","fromCharCode","compile","memoizeCompile"],"mappings":"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"}