{"version":3,"file":"main.js","sources":["../src/parser.js","../src/property.js","../src/declaration.js","../src/rule.js","../src/scope.js","../src/store.js","../src/value.js","../src/compute.js","../src/binding.js","../src/constants.js","../src/sparse-array.js","../src/template.js","../src/multi-binding.js","../src/simple-binding.js","../src/bindings.js","../src/each.js","../src/mount.js","../src/render.js","../src/changeset.js","../src/sheet.js","../src/function.js","../src/compile.js"],"sourcesContent":["// @ts-check\n\n/**\n * \n * @typedef {object} WasmParserInterface\n * @property {() => number} get_tag\n * @property {(n: number) => 1 | 0} parse\n * @property {(n: number) => number} reset\n * @property {{ buffer: ArrayBuffer }} memory\n * \n * @typedef {object} RawStringTemplate\n * @property {readonly string[] | ArrayLike<string>} raw\n * \n * @typedef {WebAssembly.Exports & WasmParserInterface} WasmParser\n*/\n\nconst INSERTION = 'ins()';\n\nconst wasm = await WebAssembly.instantiateStreaming(\n  fetch(new URL('./main.wasm', import.meta.url).toString())\n);\n\nconst instance = wasm.instance;\n\nconst exports = /** @type {WasmParser} */ (instance.exports);\n\nconst $get_tag = exports.get_tag;\nconst $memory = exports.memory;\nconst $parse = exports.parse;\nconst $reset = exports.reset;\n\nexport const mem8 = new Uint8Array($memory.buffer);\nexport const mem32 = new Uint32Array($memory.buffer);\n\n/** @type {Uint8Array} The array of the heap */\nexport let heap8;\n/** @type {Uint32Array} */\nexport let heap32;\n/** @type {Uint8Array} */\nexport let data8;\n\nconst enc = new TextEncoder();\nconst dec = new TextDecoder();\n\n/**\n * \n * @param {Uint8Array} buffer \n * @param {number} start \n * @param {number} end \n * @returns \n */\nconst readFromBuffer = (buffer, start, end) => dec.decode(buffer.slice(start, end));\n\n/** @type {number} - The length of the source */\nlet len;\n\n/* HASH function\nconst hash = (str) => {\n    let h = 5381;\n    for(let i = 0; i < str.length; i++) {\n        let c = str[i];\n      h = ((h << 5) + h) + c.charCodeAt(0);\n    }\n    return h\n};\n*/\n\n/**\n * Parses sources from a tagged template\n * @param {RawStringTemplate} source \n * @param {any[]} values\n * @returns {void}\n */\nexport function parse(source, values) {\n  let holes = values.map(_ => INSERTION);\n  let raw = String.raw(source, ...holes);\n\n  const bytes = enc.encode(raw);\n  len = bytes.byteLength;\n  const dataPtr = $reset(len);\n  mem8.set(bytes, dataPtr);\n  data8 = mem8.subarray(dataPtr);\n\n  const tagPtr = $get_tag();\n  heap8 = mem8.subarray(tagPtr);\n  heap32 = mem32.subarray(tagPtr >> 2);\n}\n\n/**\n * Parses until the next tag, returning 1 if parsing should continue\n * @returns {0|1}\n */\nexport const next = () => $parse(len);\n\n/**\n * Reading a string from the buffer.\n * @param {number} start \n * @param {number} end \n * @returns {string}\n */\nexport const readString = (start, end) => {\n  return readFromBuffer(data8, start, end);\n};\n\n/**\n * Reads the property name.\n * @returns {string}\n */\nexport const readProperty = () => readFromBuffer(data8, heap32[1], heap32[2]);\n\n/**\n * Reads the number of values in the property value.\n * @returns {number}\n */\nexport const readNumberOfValues = () => heap32[3];\n\n/**\n * Gets the first value pointer in the property.\n * @returns {number}\n */\nexport const readFirstValuePointer = () => heap32[4];","// @ts-check\n\n/**\n * @typedef {import('./pinfo').PropertyDefinition} PropertyDefinition\n * @typedef {import('./pinfo').SimplePropertyDefinition} SimplePropertyDefinition\n * @typedef {import('./pinfo').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./pinfo').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./pinfo').MultiPropertyDefinition} MultiPropertyDefinition\n * @typedef {import('./pinfo').BehaviorMultiPropertyDefinition} BehaviorMultiPropertyDefinition\n */\n\nexport const flags = {\n  text: 1 << 0,\n  classToggle: 1 << 1,\n  event: 1 << 2,\n  custom: 1 << 3,\n  each: 1 << 4,\n  prop: 1 << 5,\n  attr: 1 << 6,\n  data: 1 << 7,\n  attach: 1 << 8,\n  behavior: 1 << 9,\n  storeRoot: 1 << 10,\n  storeSet: 1 << 11\n};\n\n export const features = {\n  shorthand: 1 << 0,\n  longhand: 1 << 1,\n  keyed: 1 << 2, // Legacy, needed for sure reason\n  multi: 1 << 3,\n  oldValues: 1 << 4,\n  behavior: 1 << 5,\n  labeled: 1 << 6\n};\n\n/** @type {Record<string, PropertyDefinition>} */\nexport const properties = {\n  /** @type {SimplePropertyDefinition} */\n  'attach-template': {\n    flag: flags.attach,\n    feat: 0,\n    prop: 'attachTemplate',\n    read(el) {\n      let doc = el.ownerDocument || document;\n      let tmpl = doc.createElement('template');\n      tmpl.content.append(...Array.from(el.childNodes));\n      return tmpl;\n    }\n  },\n  /** @type {ShorthandPropertyDefinition} */\n  attr: {\n    flag: flags.attr,\n    feat: features.multi | features.shorthand | features.keyed,\n    prop: 'attr',\n    longhand: ['attr-value', 'attr-toggle'],\n    defaults: ['', true]\n  },\n  /** @type {LonghandPropertyDefinition} */\n  'attr-value': {\n    flag: flags.attr,\n    feat: features.longhand,\n    shorthand: 'attr',\n    index: 0,\n    default: '',\n    read(el, key) {\n      return ('getAttribute' in el) && el.getAttribute(key);\n    }\n  },\n  /** @type {LonghandPropertyDefinition} */\n  'attr-toggle': {\n    flag: flags.attr,\n    feat: features.longhand,\n    shorthand: 'attr',\n    index: 1,\n    default: true,\n    read(el, key) {\n      return ('hasAttribute' in el) && el.hasAttribute(key);\n    }\n  },\n  /** @type {MultiPropertyDefinition} */\n  'class-toggle': {\n    flag: flags.classToggle,\n    feat: features.multi | features.keyed,\n    prop: 'classToggle',\n    read(el, key) {\n      return ('classList' in el) && el.classList.contains(key);\n    }\n  },\n  /** @type {MultiPropertyDefinition} */\n  data: {\n    flag: flags.data,\n    feat: features.multi | features.keyed,\n    prop: 'data',\n    read(el, key) {\n      if(!('dataset' in el))\n        throw new Error(`data can only be used on HTMLElements`);\n      return /** @type {HTMLElement} */(el).dataset[key];\n    }\n  },\n  /** @type {ShorthandPropertyDefinition} */\n  each: {\n    flag: flags.each,\n    feat: features.shorthand,\n    prop: 'each',\n    longhand: ['each-items', 'each-template', 'each-key'],\n    defaults: [[], {}, null]\n  },\n  'each-items': {\n    flag: flags.each,\n    feat: features.longhand,\n    shorthand: 'each',\n    index: 0,\n    default: [],\n    read: () => null,\n  },\n  'each-template': {\n    flag: flags.each,\n    feat: features.longhand,\n    shorthand: 'each',\n    index: 1,\n    default: {},\n    read: () => null\n  },\n  'each-key': {\n    flag: flags.each,\n    feat: features.longhand,\n    shorthand: 'each',\n    index: 2,\n    default: null,\n    read: () => null\n  },\n  /** @type {ShorthandPropertyDefinition} */\n  event: {\n    flag: flags.event,\n    feat: features.multi | features.keyed | features.oldValues | features.shorthand | features.labeled,\n    prop: 'event',\n    longhand: ['event-type', 'event-listener', 'event-capture', 'event-once',\n      'event-passive', 'event-signal'],\n    defaults: [null, false, false, false, undefined]\n  },\n  'event-type': {\n    flag: flags.event,\n    feat: features.keyed | features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 0,\n    default: null,\n    read: () => null\n  },\n  'event-listener': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 1,\n    default: null,\n    read: () => null\n  },\n  'event-capture': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 2,\n    default: false,\n    read: () => false\n  },\n  'event-once': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 3,\n    default: false,\n    read: () => false\n  },\n  'event-passive': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 4,\n    default: false,\n    read: () => false\n  },\n  'event-signal': {\n    flag: flags.event,\n    feat: features.longhand | features.labeled,\n    shorthand: 'event',\n    index: 5,\n    default: undefined,\n    read: () => undefined\n  },\n  /** @type {BehaviorMultiPropertyDefinition} */\n  behavior: {\n    flag: flags.behavior,\n    feat: features.multi | features.behavior | features.oldValues,\n    prop: 'behavior'\n  },\n  /** @type {MultiPropertyDefinition} */\n  prop: {\n    flag: flags.prop,\n    feat: features.multi | features.keyed,\n    prop: 'prop',\n    read(el, key) {\n      return /** @type {any} */(el)[key];\n    }\n  },\n  /** @type {SimplePropertyDefinition} */\n  text: {\n    flag: flags.text,\n    feat: 0,\n    prop: 'text',\n    read(el) {\n      return el.textContent;\n    }\n  },\n   /** @type {SimplePropertyDefinition} */\n  'store-root': {\n    flag: flags.storeRoot,\n    feat: 0,\n    prop: 'storeRoot',\n    read: () => null\n  },\n  /** @type {SimplePropertyDefinition} */\n  'store-set': {\n    flag: flags.storeSet,\n    feat: 0,\n    prop: 'storeSet',\n    read: () => null\n  }\n};","// @ts-check\nimport { properties, features } from './property.js';\n\n/** @typedef {import('./rule').Rule} Rule */\n/** @typedef {import('./property').PropertyDefinition} PropertyDefinition */ \n/** @typedef {import('./value').Value} Value */\n/** @typedef {import('./template').ValueTemplate} ValueTemplate */\n\nexport class Declaration {\n  /**\n   * \n   * @param {Rule} rule \n   * @param {string} propertyName \n   * @param {number} sourceOrder\n   * @param {ValueTemplate} template\n   */\n  constructor(rule, propertyName, sourceOrder, template) {\n    /** @type {Rule} */\n    this.rule = rule;\n    /** @type {string} */\n    this.propertyName = propertyName;\n    /** @type {ValueTemplate | null} */\n    this.keyTemplate = null;\n    /** @type {number} */\n    this.sourceOrder = sourceOrder;\n    /** @type {ValueTemplate} */\n    this.template = template;\n    /** @type {number} */\n    this.flags = 0;\n  }\n\n  init() {\n    /** @type {PropertyDefinition | undefined} */\n    let defn = properties[this.propertyName];\n    if(defn) {\n      if(defn.feat & features.multi) {\n        this.flags |= flags.multi;\n      }\n      if(defn.feat & features.labeled) {\n        this.flags |= flags.label;\n      }\n      if(defn.feat & features.longhand) {\n        this.flags |= flags.longhand;\n      } else if(defn.feat & features.shorthand) {\n        this.flags |= flags.shorthand;\n      } else if(defn.feat & features.behavior) {\n        this.flags |= flags.behavior;\n      }\n    }\n  }\n}\n\nexport const flags = {\n  shorthand: 1 << 0,\n  longhand: 1 << 1,\n  multi: 1 << 2,\n  behavior: 1 << 3,\n  label: 1 << 4,\n};","// @ts-check\n\n/**\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./types').RootElement} RootElement\n */\n\nconst rootSelect = (/** @type {RootElement} */ el) => [el];\n/**\n * @param {RootElement} el\n * @this {Rule}\n * @returns {NodeListOf<Element>}\n */\nfunction querySelect(el) {\n  return el.querySelectorAll(this.selector);\n}\n\nexport class Rule {\n  /**\n   * @param {string} selector\n   */\n  constructor(selector) {\n    /** @type {String} */\n    this.selector = selector;\n    /** @type {Array<Declaration>} */\n    this.declarations = [];\n    /** @type {number} */\n    this.specificity = 0;\n    /** @type {(el: RootElement) => Iterable<Element | ShadowRoot | Document>} */\n    this.querySelectorAll = selector === ':root' ? rootSelect : querySelect;\n  }\n\n  /** @param {Declaration} declaration */\n  addDeclaration(declaration) {\n    this.declarations.push(declaration);\n  }\n}","\n/**\n * \n * @param {string | null} dataPropName \n * @param {string} dataSelector \n * @param {string} propName \n * @returns \n */\nexport function lookup(element, dataSelector, propName) {\n  /** @type {Element | null} */\n  let el = element;\n  do {\n    if(el.matches(dataSelector)) {\n      return /** @type {any} */(el)[Symbol.for(propName)];\n    }\n    el = element.closest(dataSelector);\n  } while(el);\n}\n\n\n\n/**\n * \n * @param {HTMLElement} element\n * @param {symbol} listSym\n * @param {string} key\n * @param {symbol} keySym\n * @param {string} dataProp\n * @param {any} value\n */\n export function addItemToScope(element, listSym, key, keySym, dataProp, value) {\n  let e = /** @type {any} */(element);\n  /** @type {Set<string>} */\n\n  let list = e[listSym];\n  if(!list) {\n    list = e[listSym] = new Set();\n  }\n  list.add(key);\n  let str = Array.from(list).join(' ');\n  element.dataset[dataProp] = str;\n\n  e[keySym] = value;\n}\n\n/**\n * \n * @param {HTMLElement} element \n * @param {symbol} listSym\n * @param {string} key\n * @param {symbol} keySym\n * @param {string} dataProp\n */\nexport function removeItemFromScope(element, listSym, key, keySym, dataProp) {\n  let e = /** @type {any} */(element);\n  /** @type {Set<string> | undefined} */\n  let list = e[listSym];\n  if(list) {\n    list.delete(key);\n    delete e[keySym];\n    if(list.size) {\n      let str = Array.from(list).join(' ');\n      element.dataset[dataProp] = str;\n    } else {\n      delete e[keySym];\n      delete element.dataset[dataProp];\n    }\n  }\n}","// @ts-check\nexport const getKeySymbol = Symbol.for('corset.getKey');\n\n/**\n * @typedef {import('./sheet').Root} Root\n */\n\nexport class Store extends Map {\n  /** @type {() => any} */\n  #update;\n  /**\n   * \n   * @param {Root} root \n   */\n  constructor(root, updateMount = true) {\n    super();\n    /** @type {Root} */\n    this.root = root;\n    /** @type {() => any} */\n    this.#update = updateMount ?\n      this.root.mount ?\n      this.root.mount.update.bind(this.root.mount) :\n      /** @type {() => void} */(Function.prototype) :\n      this.root.update.bind(this.root)\n  }\n  /**\n   * \n   * @param {any} key\n   * @returns {any}\n   */\n  [getKeySymbol](key) {\n    return this.get(key);\n  }\n  /**\n   * \n   * @param {string} k \n   * @param {any} v \n   * @returns \n   */\n  set(k, v) {\n    super.set(k, v);\n    this.#update();\n    return this;\n  }\n}\n\n/**\n * \n * @param {string} storeName \n * @returns {string}\n */\nexport const storePropName = storeName => `corset.store.${storeName}`;\n/**\n * \n * @param {string} storeName \n * @returns {string}\n */\nexport const storeDataSelector = storeName => `[data-corset-stores~=${storeName}]`;","// @ts-check\nimport { lookup } from './scope.js';\nimport { Store } from './store.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./compute').ComputedValue} ComputedValue\n * @typedef {import('./function').FunctionContext} FunctionContext\n * @typedef {import('./types').Value} Value\n * @typedef {import('./types').ValueType} ValueType\n * @typedef {import('./function').ICorsetFunctionClass} ICorsetFunctionClass\n * @typedef {import('./function').ICorsetFunction} ICorsetFunction\n */\n\nexport const NO_VALUE = Symbol('corset.noValue');\n\n/**\n * \n * @param {any} value \n * @returns {ValueType}\n */\n export const anyValue = value => \n /** @implements {Value} */\n class AnyValue{get(){ return value }};\n\n/** @implements {Value} */\nexport class InsertionValue {\n  constructor() {\n    /** @type {number} */\n    this.current = 0;\n    /** @type {any} */\n    this.value = NO_VALUE;\n  }\n  /**\n   * \n   * @param {[number]} args \n   * @param {Binding} _binding \n   * @param {Map<string, any>} _props\n   * @param {Changeset} changeset \n   * @returns {boolean}\n   */\n  check([index], _binding, _props, {values}) {\n    let value = values[index];\n    if(this.value !== value) {\n      this.value = value;\n      return true;\n    }\n    return false;\n  }\n  get() {\n    return this.value;\n  }\n}\n\n/** @implements {Value} */\nexport class SpaceSeparatedListValue {\n  /**\n   * \n   * @param {any[]} values \n   * @returns \n   */\n  get(values = []) {\n    return values;\n  }\n}\n\nexport class CommaSeparatedListValue extends SpaceSeparatedListValue {}\n\n/** @implements {Value} */\nexport class PlaceholderValue {\n  constructor() {\n    this.current = 0;\n    /** @type {NO_VALUE | ComputedValue} */\n    this.compute = NO_VALUE;\n    /** @type {any} */\n    this.value = null;\n  }\n  /**\n   * \n   * @param {[string, any]} args \n   * @param {Binding} binding \n   * @param {Map<string, any>} _props\n   * @param {Changeset} changeset \n   * @returns {boolean}\n   */\n  check(args, binding, _props, changeset) {\n    let check = false;\n    if(changeset.selectors) check = true;\n    else if(this.compute === NO_VALUE) check = true;\n    else {\n      this.compute.dirty(changeset);\n      let value = this.compute.check(changeset);\n      if(value !== this.value) {\n        this.value = value;\n        return true;\n      }\n      return false;\n    }\n    if(check) {\n      let scope = this.#get(args, binding);\n      if(scope) {\n        if(scope.value !== this.value || scope.compute !== this.compute) {\n          this.compute = scope.compute;\n          this.value = scope.value;\n          return true;\n        } else {\n          // Nothing has changed.\n          return false;\n        }\n      } else if(args.length > 1) {\n        let value = args[1];\n        if(!this.value || value !== this.value[0]) {\n          this.value = [value];\n          return true;\n        }\n        return false;\n      }\n    }\n    return false;\n  }\n  /**\n   * \n   * @param {[string, any]} args \n   * @param {Binding} param1 \n   * @returns \n   */\n  #get(args, { element }) {\n    let [propName] = args;\n    let dataSelector = `[data-corset-props~=${propName}]`;\n    return lookup(element, dataSelector, propName);\n  }\n  get() {\n    return this.value;\n  }\n}\n\n/**\n * \n * @param {ICorsetFunctionClass} CorsetFunction \n * @returns {ValueType}\n */\nexport const functionValue = (CorsetFunction) => {\n  /** @type {ICorsetFunction | undefined} */\n  let prototype = CorsetFunction.prototype;\n  if(typeof prototype !== 'object') throw new Error(`Functions must contain a prototype`);\n  /** @type {ICorsetFunction['call']} */\n  let callValue = prototype.call;\n\n  class FunctionValue {\n    static inputProperties = CorsetFunction.inputProperties;\n\n    /**\n     * @param {Binding} binding\n     */\n    constructor(binding) {\n      /** @type {FunctionContext} */\n      this.context = Object.create(binding, {\n        createStore: {\n          value() {\n            return new Store(binding.root, false);\n          }\n        }\n      });\n      /** @type {ICorsetFunction} */\n      this.fn = new CorsetFunction();\n    }\n    /**\n     * \n     * @param {any[]} args \n     * @param {Binding} _binding \n     * @param {Map<string, any> | null} props\n     * @returns {any}\n     */\n    get(args, _binding, props) {\n      return callValue.call(this.fn, args, props, this.context);\n    }\n  }\n\n  if(prototype.check) {\n    let checkValue = prototype.check;\n    /**\n     * \n     * @param {any[]} args \n     * @param {Binding} _binding \n     * @param {Map<string, any> | null} props\n     * @param {Changeset} changeset\n     */\n    FunctionValue.prototype.check = function(args, _binding, props, changeset) {\n      return checkValue.call(this.fn, args, props, this.context, changeset);\n    };\n  }\n\n  return FunctionValue;\n}","// @ts-check\n\nimport { PlaceholderValue, SpaceSeparatedListValue } from './value.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./value').Value} Value\n * @typedef {import('./types').CheckedValue} CheckedValue\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * \n * @typedef {(c: Changeset, v: number) => number} VersionCalculate\n */\n\nexport class ComputedValue {\n  /** @type {boolean} */\n  #initial = true;\n  /** @type {any} */\n  #value;\n  /** @type {WeakMap<Changeset, boolean>} */\n  #dirty = new WeakMap();\n  /** @type {CheckedValue['check'] | undefined} */\n  #check;\n  /**\n   * \n   * @param {ValueTemplate} template \n   * @param {Binding} binding \n   * @param {number} index\n   */\n  constructor(template, binding, index = 0) {\n    /** @type {Binding} */\n    this.binding = binding;\n    /** @type {number} */\n    this.index = index;\n    /** @type {any[]} */\n    this.args = [];\n    /** @type {ComputedValue[]} */\n    this.argDeps = [];\n    /** @type {Map<string, ComputedValue> | null} */\n    this.inputDeps = null;\n    /** @type {Map<string, any> | null} */\n    this.inputProps = null;\n    /** @type {Value} */\n    this.raw = hydrate(this, template);\n    /** @type {() => any[]} */\n    this.listValue = this.raw instanceof SpaceSeparatedListValue ?\n      () => this.#value :\n      () => [this.#value];\n\n    // Private\n    this.#value = null;\n    this.#check = this.raw.check;\n  }\n  /**\n   * \n   * @param {number} index \n   * @param {ComputedValue} dep\n   * @param {Changeset} changeset\n   */\n  set(index, dep, changeset) {\n    let deps = this.argDeps;\n    if(deps[index] !== dep) {\n      this.#dirty.set(changeset, true);\n    }\n    deps[index] = dep;\n  }\n  /**\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  dirty(changeset) {\n    if(this.#initial) {\n      this.calculate(changeset);\n      this.#dirty.set(changeset, true);\n      this.#initial = false;\n    }\n    if(this.#dirty.has(changeset)) {\n      return /** @type {boolean} */(this.#dirty.get(changeset));\n    }\n    this.calculate(changeset);\n    return /** @type {boolean} */(this.#dirty.get(changeset));\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   */\n  compute(changeset) {\n    this.#value = call(this, changeset, this.raw.get);\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns {any}\n   */\n  check(changeset) {\n    if(this.dirty(changeset)) {\n      this.compute(changeset);\n    }\n    return this.#value;\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns {boolean}\n   */\n  calculate(changeset) {\n    if(this.#dirty.has(changeset)) {\n      return /** @type {boolean} */(this.#dirty.get(changeset));\n    }\n    let dirty = false;\n    if(this.#check) {\n      if(call(this, changeset, this.#check)) {\n        dirty = true;\n      }\n    }\n\n    for(let dep of this.#allDeps()) {\n      if(dep.calculate(changeset)) {\n        dirty = true;\n      }\n    }\n\n    this.#dirty.set(changeset, dirty);\n    return dirty;\n  }\n  * #allDeps() {\n    yield * this.argDeps;\n    if(this.inputDeps) {\n      yield * this.inputDeps.values();\n    }\n  }\n}\n\n/**\n * \n * @param {ComputedValue} compute \n * @param {ValueTemplate} template \n * @returns {Value}\n */\nfunction hydrate(compute, template) {\n  let value = new template.Value(compute.binding);\n  for(let dep of template.deps) {\n    compute.argDeps.push(new ComputedValue(dep, compute.binding));\n  }\n  let inputProperties = template.inputProperties;\n  if(inputProperties) {\n    compute.inputProps = new Map();\n    compute.inputDeps = new Map();\n    for(let [propName, template] of inputProperties) {\n      compute.inputDeps.set(propName, new ComputedValue(template, compute.binding));\n    }\n  }\n  return value;\n}\n\n/**\n * @param {ComputedValue} compute \n * @param {Changeset} changeset\n * @param {Value['get'] | CheckedValue['check']} method\n * @returns {any}\n */\nfunction call(compute, changeset, method) {\n  let {args, binding, raw: value, inputProps: props} = compute;\n  if(compute.inputDeps) {\n    for(let [propName, v] of compute.inputDeps) {\n      let value = v.check(changeset);\n      if((v.raw instanceof PlaceholderValue) && Array.isArray(value)) {\n        value = value[0];\n      }\n      /** @type {Map<string, any>} */(props).set(propName, value);\n    }\n  }\n  args.length = 0;\n  for(let v of compute.argDeps) {\n    if(v.raw instanceof PlaceholderValue) {\n      let values = v.check(changeset);\n      if(values) args.push(...values);\n    }\n    else\n      args.push(v.check(changeset)); \n  }\n  return method.call(value, args, binding, props, changeset);\n}","// @ts-check\nimport { ComputedValue } from './compute.js';\nimport { NO_VALUE } from './value.js';\n\n/**\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./property').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./property').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./pinfo').PropertyPropName} PropertyPropName\n * @typedef {import('./sheet').Root} Root\n * @typedef {import('./types').RootElement} RootElement\n */\n\n/**\n * \n * @param {any[]} sorted \n * @param {any} item \n * @param {(a: any, b: any) => boolean} comparator\n * @returns {number}\n */\n function binaryInsert(sorted, item, comparator) {\n  if(sorted.length === 0) {\n    sorted.push(item);\n    return 0;\n  }\n  let low = 0, high = sorted.length - 1, mid = 0;\n  while (low <= high) {\n    mid = low + (high - low >> 1);\n    if(comparator(sorted[mid], item)) {\n      low = mid + 1;\n    } else {\n      high = mid -1;\n    }\n  }\n\n  if(comparator(sorted[mid], item)) {\n    mid++;\n  }\n\n  sorted.splice(mid, 0, item);\n  return mid;\n}\n\n/**\n * Sort a declaration first by selector specificity, then by rule index,\n * then by declaration index\n * @param {Declaration} d1\n * @param {Declaration} d2\n * @returns {boolean}\n */\nfunction compare(d1, d2) {\n  return d1.rule.specificity === d2.rule.specificity ?\n    d1.sourceOrder < d2.sourceOrder :\n    d1.rule.specificity < d2.rule.specificity;\n}\n\nexport class Binding {\n  /**\n   * \n   * @param {string} propertyName\n   * @param {Root} root\n   * @param {Element | ShadowRoot | Document} element\n   */\n  constructor(propertyName, root, element) {\n    this.root = root;\n    /** @type {string} */\n    this.propertyName = propertyName;\n    /** @type {RootElement} */\n    this.rootElement = root.rootElement;\n    /** @type {Element | ShadowRoot | Document} */\n    this.element = element;\n    /** @type {Declaration[]} */\n    this.declarations = [];\n    /** @type {Map<Declaration, ComputedValue>} */\n    this.computedValues = new Map();\n    /** @type {ComputedValue | null} */\n    this.compute = null;\n    /** @type {any} */\n    this.value = NO_VALUE;\n    /** @type {any} */\n    this.initial = NO_VALUE;\n  }\n  /**\n   * \n   * @param {Declaration} declaration\n   * @returns {ComputedValue}\n   */\n  add(declaration) {\n    return this.addTemplate(declaration, declaration.template);\n  }\n  /**\n   * \n   * @param {Declaration} declaration \n   */\n  push(declaration) {\n    binaryInsert(this.declarations, declaration, compare);\n  }\n  /**\n   * \n   * @param {Declaration} declaration \n   * @param {ValueTemplate} template \n   * @param {number} [index]\n   * @returns {ComputedValue}\n   */\n  addTemplate(declaration, template, index) {\n    /** @type {ComputedValue} */\n    let compute = new ComputedValue(template, this, index);\n    this.computedValues.set(declaration, compute);\n    return compute;\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns \n   */\n  dirty(changeset) {\n    if(this.value === NO_VALUE) {\n      return true;\n    } else {\n      let compute = this.compute;\n      this.compute = this.#find();\n      if(compute !== this.compute) return true;\n      return compute ? compute.dirty(changeset) : false;\n    }\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   */\n  update(changeset) {\n    if(this.compute === null) {\n      this.compute = this.#find();\n    }\n    if(this.compute === null) {\n      this.value = this.initial;\n    } else {\n      this.value = this.compute.check(changeset);\n    }\n    return this.value;\n  }\n  /**\n   * \n   * @returns {any[]}\n   */\n  getList() {\n    return this.compute?.listValue() || [];\n  }\n  /**\n   * Whether this binding has received a value yet or not.\n   * @returns {boolean}\n   */\n  hasValue() {\n    return this.value !== NO_VALUE;\n  }\n  /**\n   * \n   * @returns {ComputedValue | null}\n   */\n  #find() {\n    let declaration = this.#firstMatch();\n    if(declaration) {\n      /** @type {ComputedValue} */\n      let compute = /** @type {ComputedValue} */(this.computedValues.get(declaration));\n      return compute;\n    }\n    return null;\n  }\n  *walk() {\n    let { element } = this;\n    let sorted = this.declarations;\n\n    let i = sorted.length;\n    /** @type {Declaration} */\n    let declaration;\n    while(i > 0) {\n      i--;\n      declaration = sorted[i];\n      if(this.matches(declaration.rule.selector)) {\n        yield declaration;\n      }\n    }\n  }\n  /**\n   * \n   * @param {string} selector \n   * @returns {boolean}\n   */\n  matches(selector) {\n    let element = this.element;\n    if(selector === ':root')\n      return true;\n    else if('matches' in element)\n      return element.matches(selector);\n    else return false;\n  }\n  /**\n   * \n   * @returns {Declaration | void}\n   */\n  #firstMatch() {\n    for(let declaration of this.walk()) {\n      return declaration;\n    }\n  }\n}","// @ts-check\n\n/**\n * @typedef {{}} Constant\n * \n * @typedef {((value: string) => Constant) & { map: Map<string, Constant>; for: (s: string) => Constant; base: Object; is: (value: any) => boolean; }} ConstantCreator\n */\n\nconst ConstantMethods = {\n  /**\n  * \n  * @param {string} value \n  * @returns {Constant}\n  * @this {ConstantCreator}\n  */\n  for(value) {\n    let map = /** @type {Map<string, Constant>} */(/** @type {unknown} */(this.map));\n    return /** @type {Constant} */(map.get(value) ||\n      (map.set(value, this(value))) && map.get(value));\n  },\n\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   * @this {ConstantCreator}\n   */\n  is(value) {\n    return Object.prototype.isPrototypeOf.call(this.base, value);\n  }\n};\n\n/**\n * \n * @returns {ConstantCreator}\n */\nlet createConstant = () => {\n  /**\n   * @param {string} value\n   */\n  function ConstantBase(value) {\n    return Object.create(ConstantBase.base, {\n      name: { enumerable: false, writable: false, configurable: false, value }\n    });\n  }\n  ConstantBase.base = Object.create(null);\n  ConstantBase.map = new Map();\n  Object.assign(ConstantBase, ConstantMethods);\n  return /** @type {ConstantCreator} */(/** @type {unknown} */(ConstantBase));\n};\n\nexport const Name = createConstant();\nexport const Keyword = createConstant();\n\nexport const KEYWORD_REVERT_SHEET = Keyword('revert-sheet');\nexport const KEYWORD_ALL = Keyword('all');","// @ts-check\n\nimport { NO_VALUE } from './value.js';\n\n/**\n * @template {string | null} K\n * @extends {Array}\n */\nexport class SparseArray extends Array {\n  /**\n   * \n   * @param {number} len \n   */\n  constructor(len) {\n    super(len);\n    this.fill(NO_VALUE);\n    this.numberOfValues = 0;\n  }\n  /**\n   * \n   * @param {number} index \n   * @returns \n   */\n  empty(index) {\n    return this[index] === NO_VALUE;\n  }\n  /**\n   * @returns {boolean}\n   */\n  full() {\n    return this.numberOfValues === this.length;\n  }\n  /**\n   * \n   * @param {number} index \n   * @param {any} item \n   */\n  set(index, item) {\n    this[index] = item;\n    this.numberOfValues++;\n  }\n}","// @ts-check\n\nimport { anyValue, PlaceholderValue } from './value.js';\n\n/**\n * @typedef {import('./value').ValueType} ValueType\n */\n\n/**\n * \n * @typedef {Object} ValueTemplate\n * @property {ValueType} Value\n * @property {ValueTemplate[]} deps\n * @property {Map<string, ValueTemplate> | null} [inputProperties]\n */\n\n/**\n * \n * @param {ValueType} Value \n * @param {ValueTemplate[]} deps\n * @returns {ValueTemplate}\n */\nexport function createValueTemplate(Value, deps = []) {\n  /** @type {ValueTemplate} */\n  let template = {\n    Value,\n    deps,\n    inputProperties: null\n  };\n\n  if(Value.inputProperties) {\n    /** @type {Map<string, ValueTemplate>} */\n    let map = new Map();\n    for(let propName of Value.inputProperties) {\n      map.set(propName, createValueTemplate(PlaceholderValue, [\n        createValueTemplate(anyValue(propName))\n      ]));\n    }\n    template.inputProperties = map;\n  }\n\n  return template\n}","// @ts-check\nimport { Binding } from './binding.js';\nimport { ComputedValue } from './compute.js';\nimport { flags as declFlags } from './declaration.js';\nimport { Name } from './constants.js';\nimport { properties, features } from './property.js';\nimport { SparseArray } from './sparse-array.js';\nimport { createValueTemplate } from './template.js';\nimport { SpaceSeparatedListValue } from './value.js';\nimport { KEYWORD_ALL, KEYWORD_REVERT_SHEET } from './constants.js';\n\n/**\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./constants').Constant} Constant\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./pinfo').MultiPropertyDefinition} MultiPropertyDefinition\n * @typedef {import('./property').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./property').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./property').BehaviorMultiPropertyDefinition} BehaviorMultiPropertyDefinition\n */\n\n/**\n * \n * @param {Declaration} declaration \n * @returns {ValueTemplate}\n */\n function createPrependedKeyedTemplate(declaration) {\n  return createValueTemplate(SpaceSeparatedListValue, [\n    /** @type {ValueTemplate} */(declaration.keyTemplate)\n  ].concat(declaration.template.deps))\n}\n\n/**\n * @typedef {string | Constant | null | MountedBehaviorType} MultiBindingKey\n */\n\n/**\n * @template {string | Constant | Array<any> | MountedBehaviorType} K\n */\nexport class MultiBinding extends Binding {\n  /**\n   * @param {ShorthandPropertyDefinition | MultiPropertyDefinition | BehaviorMultiPropertyDefinition} defn\n   * @param {ConstructorParameters<typeof Binding>} args\n   */\n  constructor(defn, ...args) {\n    super(...args);\n\n    /** @type {ShorthandPropertyDefinition | MultiPropertyDefinition | BehaviorMultiPropertyDefinition} */\n    this.defn = defn;\n\n    /** @type {number} */\n    this.numberOfValues =\n      /** @type {ShorthandPropertyDefinition} */(defn).longhand?.length || 2;\n\n    /** @type {number} */\n    this.numberOfValuesWithKey = this.numberOfValues + (defn.feat & features.keyed ? 1 : 0);\n\n    /** @type {Set<MultiBindingKey>} */\n    this.active = new Set();\n    /** @type {Map<MultiBindingKey, readonly any[]>} */\n    this.initial = new Map();\n    /** @type {Map<MultiBindingKey, any[]> | null} */\n    this.oldValues = defn.feat & features.oldValues ? new Map() : null;\n  }\n  /**\n  * \n  * @param {Declaration} declaration \n  */\n  add(declaration) {\n    this.push(declaration);\n\n    let propName = declaration.propertyName;\n    switch(declaration.flags) {\n      // Unkeyed multi\n      case declFlags.multi | declFlags.shorthand:\n      // behavior: mount(Behavior)\n      case declFlags.multi | declFlags.behavior:\n      // event: [label] type callback\n      case declFlags.multi | declFlags.shorthand | declFlags.label:\n      // class-toggle: one \"one\", two \"two\"\n      case declFlags.multi:\n      // each: ${items} select(template)\n      case declFlags.shorthand: {\n        return this.addTemplate(declaration, declaration.template);\n      }\n      // each-items: ${items}\n      case declFlags.longhand:\n      // event-once: [label] true\n      case declFlags.longhand | declFlags.label: {\n        let defn = /** @type {LonghandPropertyDefinition} */(properties[propName]);\n        return this.addTemplate(declaration, declaration.template, defn.index);\n      }\n      default: {\n        throw new Error('Unknown property type');\n      }\n    }\n  }\n  /**\n  * \n  * @param {Changeset} changeset \n  * @returns {Generator<[[K, ...any[]], boolean], void, unknown>}\n  */\n  * calculate(changeset) {\n    let sorted = this.declarations;\n    let active = new Set(this.active);\n    /** @type {Set<MultiBindingKey>} */\n    let unset = new Set();\n\n    /**\n     * @typedef {SparseArray<K extends string ? K : null>} KeyedSparseArray\n     */\n\n    /** @type {Map<string | Constant | null, KeyedSparseArray>} */\n    let valueMap = new Map();\n    let getValueList =\n    /**\n     * \n     * @param {string | Constant | null} key \n     * @param {number} numOfValues \n     * @return {KeyedSparseArray}\n     */\n    function(key, numOfValues) {\n      /** @type {KeyedSparseArray} */\n      let valueList;\n      if(valueMap.has(key))\n        valueList = /** @type {KeyedSparseArray} */(valueMap.get(key));\n      else {\n        valueList = new SparseArray(numOfValues);\n        valueMap.set(key, valueList);\n      }\n      return valueList;\n    };\n\n    /** @type {Set<string | Constant | null>} */\n    let dirtyKeys = new Set();\n\n    let i = sorted.length;\n    /** @type {Declaration} */\n    let declaration;\n    loop: while(i > 0) {\n      i--;\n      declaration = sorted[i];\n      if(this.matches(declaration.rule.selector)) {\n        let compute = /** @type {ComputedValue} */(this.computedValues.get(declaration));\n\n        let dirty = compute.dirty(changeset);\n        let computedValue = compute.check(changeset);\n\n        switch(declaration.flags) {\n          // attr: \"type\" \"text\"\n          case declFlags.multi | declFlags.shorthand:\n          // class-toggle: one \"one\", two \"two\"\n          case declFlags.multi: {\n            for(let values of /** @type {[K, ...any[]][]} */(computedValue)) {\n              let key = /** @type {string | Constant} */(values[0]);\n\n              let idx = Name.is(key) ? 1 : 0;\n              if(values[1] === KEYWORD_REVERT_SHEET) {\n                if(key === KEYWORD_ALL) {\n                  for(let val of this.active) {\n                    unset.add(val);\n                  }\n                  break;\n                }\n                else {\n                  unset.add(key);\n                  break;\n                }\n              } else if(unset.has(key) || typeof key === 'undefined') {\n                break;\n              }\n\n              if(values.length === 1) break;\n              this.#bookkeep(active, key);\n              if(dirty) dirtyKeys.add(key);\n              let valueList = getValueList(key, this.numberOfValuesWithKey);\n              for(let i = 0; idx < values.length; i++, idx++) {\n                if(valueList.empty(i))\n                  valueList.set(i, values[idx]);\n              }\n            }\n            break;\n          }\n          // event: [label] type callback, [another-label] type callback\n          case declFlags.multi | declFlags.shorthand | declFlags.label: {\n            for(let values of /** @type {[K, ...any[]][]} */(computedValue)) {\n              let key = /** @type {string | Constant} */(values[0]);\n              let isName = Name.is(key);\n              if(!isName) {\n                key = Name.for('corset.default.' + key);\n              }\n              else\n                values = /** @type {[K, ...any[]]} */(values.slice(1));\n\n              this.#bookkeep(active, key, isName ? values[1] : values[0]);\n              let valueList = getValueList(key, this.numberOfValues);\n              for(let i = 0; i < values.length; i++) {\n                if(valueList.empty(i))\n                  valueList.set(i, values[i]);\n              }\n              if(dirty) dirtyKeys.add(key);\n            }\n            break;\n          }\n          // behavior: mount(Behavior)\n          case declFlags.multi | declFlags.behavior: {\n            for(let [values] of computedValue) {\n              let Behavior = values[0];\n              this.#bookkeep(active, Behavior);\n              let allValues = this.#appendToValues(Behavior, values);\n              yield [allValues, dirty];\n              this.oldValues?.set(Behavior, values);\n            }\n            break loop;\n          }\n          // each-items: ${items};\n          case declFlags.longhand: {\n            let keyed = this.defn.feat & features.keyed;\n            /** @type {string | null} */\n            let key = keyed ? computedValue[0] : null;\n            /** @type {any} */\n            let propValue = keyed ? computedValue[1] : computedValue[0];\n            let idx = compute.index + (keyed ? 1 : 0);\n\n            this.#bookkeep(active, key);\n            let valueList = getValueList(key, this.numberOfValuesWithKey);\n            if(keyed && valueList.empty(0))\n              valueList.set(0, computedValue[0]);\n            if(valueList.empty(idx))\n              valueList.set(idx, propValue);\n            if(dirty)\n              dirtyKeys.add(key);\n\n            if(valueList.full()) {\n              if(this.oldValues) this.oldValues.set(key, Array.from(valueList));\n              yield [\n                /** @type {[K, ...any[]]} */(/** @type {unknown} */(valueList)),\n                dirty || dirtyKeys.has(key)\n              ];\n              valueMap.delete(key);\n              dirtyKeys.delete(key);\n              break;\n            }\n\n            break;\n          }\n          // event-once: [name] true;\n          case declFlags.longhand | declFlags.label: {\n            let hasLabel = Name.is(computedValue[0]);\n            /** @type {Name} */\n            let key = hasLabel ? computedValue[0] : Name.for('corset.default.' + computedValue[0]);\n            /** @type {any} */\n            let propValue = computedValue[1];\n\n            this.#bookkeep(active, key, computedValue[0]);\n            let valueList = getValueList(key, this.numberOfValues);\n            if(!hasLabel && valueList.empty(0))\n              valueList.set(0, computedValue[0]);\n            if(valueList.empty(compute.index))\n              valueList.set(compute.index, propValue);\n            if(dirty)\n              dirtyKeys.add(key);\n            break;\n          }\n          // each: ${items} select(template)\n          case declFlags.shorthand: {\n            this.#bookkeep(active, null);\n            yield [this.#appendToValues(null, computedValue, false), dirty];\n            break;\n          }\n          default: {\n            throw new Error(`This is not supported`);\n          }\n        }\n      }\n    }\n\n    // Fill in the defaults by looking at the valueMap for holes.\n    for(let [key, values] of valueMap) {\n      if(!dirtyKeys.has(key)) continue;\n      // valueMap is always appended from a longhand prop.\n      let numOfValues = this.numberOfValues;\n      let keyed = this.defn.feat & features.keyed;\n      let i = keyed ? 1 : 0;\n      while(i < numOfValues) {\n        if(values.empty(i)) {\n          values[i] = /** @type {ShorthandPropertyDefinition} */(this.defn).defaults[i - (keyed ? 1 : 0)];\n        }\n        i++;\n      }\n      if(this.oldValues) {\n        let current = this.oldValues.get(key);\n        this.oldValues.set(key, values.slice());\n        if(current) {\n          values.push(...current);\n        }\n      }\n      yield [/** @type {[K, ...any[]]} */(/** @type {unknown} */(values)), true];\n    }\n\n    // Yield out to reset to initial state.\n    for(let key of active) {\n      let initialValues = this.initial.get(key) || [];\n      let valuesWithKey = this.defn.feat & features.keyed && !Name.is(key) ? [key, ...initialValues] : Array.from(initialValues);\n      let allValues = this.#appendToValues(key, /** @type {[K, ...any[]]} */(valuesWithKey));\n      yield [allValues, true];\n      this.active.delete(key);\n    }\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   * @returns {Generator<any[], void, unknown>}\n   */\n  * values(changeset) {\n    for(let [values] of this.calculate(changeset)) {\n      yield values;\n    }\n  }\n  /**\n   * \n   * @returns {Generator<any[], void, unknown>}\n   */\n  * current() {\n    if(!this.oldValues) return;\n    for(let [key, values] of this.oldValues) {\n      /** @type {any[]} */\n      let out = key ? [key] : [];\n      yield out.concat(values);\n    }\n  }\n  /**\n   * \n   * @param {Changeset} changeset \n   */\n  * changes(changeset) {\n    for(let [values, dirty] of this.calculate(changeset)) {\n      if(dirty)\n        yield values;\n    }\n  }\n  /**\n   * \n   * @param {string | Constant | MountedBehaviorType} key \n   * @param {string} [type]\n   */\n  #setInitials(key, type) {\n    if(!this.initial.has(key)) {\n      /** @type {any[]} */\n      let values = [];\n      if(this.defn.longhand) {\n        let i = 0, len = this.defn.longhand.length;\n        while(i < len) {\n          let lhDefn = /** @type {LonghandPropertyDefinition} */(properties[this.defn.longhand[i]]);\n          values[i] = lhDefn.read(\n            this.element,\n            /** @type {string} */(key)\n          );\n          i++;\n        }\n        if(type) values[0] = type;\n      } else if(this.defn.feat & features.behavior) {\n        values = [null, null];\n      } else if(this.defn.read) {\n        values[0] = this.defn.read(this.element, /** @type {string} */(key));\n      }\n      this.initial.set(key, Object.freeze(values));\n    }\n  }\n  /**\n   * \n   * @param {Set<MultiBindingKey>} active \n   * @param {MultiBindingKey} key \n   * @param {string} [type]\n   */\n  #bookkeep(active, key, type) {\n    active.delete(key);\n    if(key !== null) this.#setInitials(key, type);\n    this.active.add(key);\n  }\n  /**\n   * @param {MultiBindingKey} key\n   * @param {[K, ...any[]]} values \n   * @param {boolean} keyed\n   * @returns {[K, ...any[]]}\n   */\n  #appendToValues(key, values, keyed = true) {\n    if(values.length === this.numberOfValuesWithKey && this.oldValues === null)\n      return values;\n    /** @type {any[]} */\n    let append = [];\n    let keyIsName = Name.is(key);\n    if(typeof key === 'string') append.push(key);\n    let i = append.length + values.length;\n    let d = keyed ? 1 : 0;\n    let numOfValues = keyIsName ? this.numberOfValues : this.numberOfValuesWithKey;\n    while(i < numOfValues) {\n      append.push(/** @type {ShorthandPropertyDefinition} */(this.defn).defaults[i - d]);\n      i++;\n    }\n    if(this.oldValues && this.oldValues.has(key)) {\n      let oldValues = /** @type {any[]} */(this.oldValues.get(key));\n      append.push(...oldValues);\n    }\n    return /** @type {[K, ...any[]]} */(values.concat(append));\n  }\n}","// @ts-check\n\nimport { Binding } from './binding.js';\nimport { properties } from './property.js';\n\n/**\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./property').SimplePropertyDefinition} SimplePropertyDefinition\n * @typedef {import('./sheet').Root} Root\n */\n\nexport class SimpleBinding extends Binding {\n  /**\n   * \n   * @param {SimplePropertyDefinition} defn\n   * @param {string} propName \n   * @param {[Root, Element | ShadowRoot | Document]} args \n   */\n  constructor(defn, propName, ...args) {\n    super(propName, ...args);\n\n    /** @type {SimplePropertyDefinition} */\n    this.defn = defn;\n\n    /** @type {any} */\n    this.initial = this.defn.read(this.element);\n  }\n}","// @ts-check\n\nimport { Binding } from './binding.js';\nimport { MultiBinding } from './multi-binding.js';\nimport { SimpleBinding } from './simple-binding.js';\nimport { flags, properties, features } from './property.js';\n\n/**\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n * @typedef {import('./declaration').Declaration} Declaration\n * @typedef {import('./property').MultiPropertyDefinition} MultiPropertyDefinition\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./property').SimplePropertyDefinition} SimplePropertyDefinition\n * @typedef {import('./property').ShorthandPropertyDefinition} ShorthandPropertyDefinition\n * @typedef {import('./property').BehaviorMultiPropertyDefinition} BehaviorMultiPropertyDefinition\n * @typedef {import('./property').LonghandPropertyDefinition} LonghandPropertyDefinition\n * @typedef {import('./sheet').Root} Root\n * @typedef {import('./types').RootElement} RootElement\n */\n\n\nexport class Bindings {\n  /**\n   * Create bindings for a specific element.\n   * @param {Root} root\n   * @param {RootElement} element\n   */\n  constructor(root, element) {\n    this.root = root;\n    /** @type {RootElement} */\n    this.element = element;\n    /** @type {WeakSet<Declaration>} */\n    this.seen = new WeakSet();\n\n    /** @type {Binding | null} */\n    this.attachTemplate = null;\n    /** @type {MultiBinding<MountedBehaviorType> | null} */\n    this.behavior = null;\n    /** @type {Binding | null} */\n    this.text = null;\n    /** @type {MultiBinding<string> | null} */\n    this.data = null;\n    /** @type {MultiBinding<any[]> | null} */\n    this.each = null;\n    /** @type {MultiBinding<string> | null} */\n    this.event = null;\n    /** @type {MultiBinding<string> | null} */\n    this.attr = null;\n    /** @type {MultiBinding<string> | null} */\n    this.classToggle = null;\n    /** @type {Binding | null} */\n    this.mount = null;\n    /** @type {MultiBinding<string> | null} */\n    this.prop = null;\n    /** @type {Binding | null} */\n    this.storeRoot = null;\n    /** @type {Binding | null} */\n    this.storeSet = null;\n\n    /** @type {Map<string, Binding>} */\n    this.custom = new Map();\n    /** @type {number} */\n    this.flags = 0;\n  }\n\n  /**\n   * Add a declaration to the binding map\n   * @param {Declaration} declaration \n   * @returns \n   */\n  add(declaration) {\n    if(this.seen.has(declaration)) return;\n    this.seen.add(declaration);\n    let propName = declaration.propertyName;\n\n    if(propName in properties) {\n      /** @type {PropertyDefinition} */\n      let defn = properties[propName];\n\n      this.flags |= defn.flag;\n\n      /** @type {MultiPropertyDefinition | ShorthandPropertyDefinition | BehaviorMultiPropertyDefinition | undefined} */\n      let multiDef = undefined;\n      if(defn.feat & features.multi || 'longhand' in defn) {\n        multiDef = /** @type {MultiPropertyDefinition} */(defn);\n      }\n      else if('shorthand' in defn)\n        multiDef = /** @type {ShorthandPropertyDefinition} */(properties[/** @type {LonghandPropertyDefinition} */(defn).shorthand]);\n      if(multiDef) {\n        if(!this[multiDef.prop]) {\n          this[multiDef.prop] = /** @type {MultiBinding<string> & MultiBinding<any[]> & MultiBinding<MountedBehaviorType>} */\n          (new MultiBinding(multiDef, propName, this.root, this.element));\n        }\n\n        let kb = /** @type {MultiBinding<any>} */(this[multiDef.prop]);\n        kb.add(declaration);\n      } else {\n        let binding = this.#getOrAddBinding(\n          propName,\n          /** @type {SimplePropertyDefinition} */(defn)\n        );\n        binding.push(declaration);\n        binding.add(declaration);\n      }\n    } else if(propName.startsWith('--')) {\n      /** @type {Binding} */\n      let binding = this.#getOrAddBinding(propName, null);\n      binding.push(declaration);\n      binding.add(declaration);\n      this.flags |= flags.custom;\n      this.custom.set(propName, binding);\n    }\n  }\n\n  /**\n   * \n   * @param {string} propertyName\n   * @param {SimplePropertyDefinition | null} defn\n   * @returns {Binding}\n   */\n  #getOrAddBinding(propertyName, defn) {\n    let bindingProp = defn ? defn.prop : propertyName;\n    if(!defn) {\n      if(!this.custom.has(propertyName)) {\n        let binding = new Binding(propertyName, this.root, this.element);\n        this.custom.set(propertyName, binding);\n      }\n      return /** @type {Binding} */(this.custom.get(propertyName));\n    } else if(! /** @type {any} */(this)[bindingProp]) {\n      let binding = new SimpleBinding(defn, propertyName, this.root, this.element);\n      /** @type {any} */(this)[bindingProp] = binding;\n    }\n    return /** @type {any} */(this)[bindingProp];\n  }\n}","// @ts-check\nimport { addItemToScope } from './scope.js';\nconst eachSymbol = Symbol.for('corset.each');\nconst itemSymbol = Symbol.for('corset.item');\nconst indexSymbol = Symbol.for('corset.index');\n\n/**\n * @typedef {object} FragData\n * @property {any} item\n * @property {number} index\n * \n * @typedef {DocumentFragment & { nodes: Array<ChildNode>; data: FragData }} EachFragment\n * @typedef {import('./types').HostElement} HostElement\n */\n\nexport class EachInstance {\n  /** @type {Map<any, EachFragment>} */\n  keyMap = new Map();\n  /**\n   * @param {HostElement} host \n   * @param {HTMLTemplateElement} template\n   * @param {string} key\n   */\n  constructor(host, template, key) {\n    /** @type {HostElement} */\n    this.host = host;\n    /** @type {HTMLTemplateElement} */\n    this.template = template;\n    /** @type {string} */\n    this.key = key;\n    /** @type {(item: any, index: number) => any} */\n    this.keyFn = this.key ? this.keyKeyed : this.keyNonKeyed;\n\n    let doc = this.host.ownerDocument ?? document;\n\n    /** @type {Comment} */\n    this.start = doc.createComment(`each(items)`)\n    /** @type {Comment} */\n    this.end = doc.createComment(`end each(items)`);\n\n    this.host.append(this.start);\n    this.start.after(this.end);\n\n    /** @type {EachFragment[]} */\n    this.frags = [];\n    /** @type {any[]} */\n    this.keys = [];\n  }\n  /**\n   * \n   * @param {any[]} values\n   */\n  set(values) {\n    return this.updateValues(values);\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @param {*} value \n   * @param {*} index \n   */\n  setData(frag, value, index) {\n    for(let element of frag.nodes) {\n      if('dataset' in element) {\n        let e = /** @type {HTMLElement} */(element);\n        addItemToScope(e, eachSymbol, 'item', itemSymbol, 'corsetScope', value);\n        addItemToScope(e, eachSymbol, 'index', indexSymbol, 'corsetScope', index);\n\n        // /** @type {HTMLElement} */\n        // (element).dataset[itemProp] = '';\n        // /** @type {any} */\n        // (element)[Symbol.for(itemProp)] = value;\n        //  /** @type {HTMLElement} */\n        // (element).dataset[indexProp] = '';\n        // /** @type {any} */\n        // (element)[Symbol.for(indexProp)] = index;\n      }\n\n    }\n  }\n  /**\n   * \n   * @param {number} index \n   * @param {any} value \n   * @returns \n   */\n  render(index, value) {\n    let doc = this.host.ownerDocument || document;\n    /** @type {EachFragment} */\n    let frag = /** @type {EachFragment} */(doc.importNode(this.template.content, true));\n    frag.nodes = Array.from(frag.childNodes);\n    frag.data = { item: value, index };\n    this.setData(frag, value, index);\n    return frag;\n  }\n  /**\n   * \n   * @param {any} _ \n   * @param {number} index \n   * @returns {any}\n   */\n  keyNonKeyed(_, index) {\n    return index;\n  }\n  /**\n   * \n   * @param {any} value \n   * @returns \n   */\n  keyKeyed(value) {\n    return value[this.key];\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @returns \n   */\n  refrag(frag) {\n    if(!frag.firstChild && frag.nodes)\n      frag.append(...frag.nodes);\n    return frag;\n  }\n  /**\n   * @param {EachFragment} frag\n   * @param {EachFragment} ref\n   */\n  append(frag, ref) {\n    let sibling = ref ? ref.nodes[ref.nodes.length - 1] : this.start;\n    sibling.after(this.refrag(frag));\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @param {EachFragment} ref \n   */\n  before(frag, ref) {\n    let sibling = ref ? ref.nodes[0] : this.end;\n    sibling.before(this.refrag(frag));\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   */\n  remove(frag) {\n    let lastNode = frag.nodes[frag.nodes.length - 1];\n    this.clear(frag.nodes[0], /** @type {Comment} */(lastNode.nextSibling));\n  }\n  clear(startNode = this.start.nextSibling, end = this.end) {\n    /** @type {ChildNode | null} */\n    let node = /** @type {ChildNode} */(startNode);\n    /** @type {ChildNode | null} */\n    let next;\n    while(node !== end) {\n      next = /** @type {ChildNode} */(node).nextSibling;\n      /** @type {ChildNode} */(node).remove();\n      node = next;\n    }\n  }\n  /**\n   * \n   * @param {EachFragment} frag \n   * @param {number} index \n   * @param {any} value \n   * @returns \n   */\n  updateFrag(frag, index, value) {\n    if(frag.data.item !== value || frag.data.index !== index) {\n      this.setData(frag, value, index);\n    }\n    return frag;\n  }\n  /**\n   * \n   * @param {any[]} values\n   */\n  updateValues(values = []) {\n    let invalid = false,\n      /** @type {EachFragment[]} */\n      oldFrags = this.frags,\n      /** @type {EachFragment[]} */\n      newFrags = [],\n      oldKeys = this.keys;\n\n    let expectedMap = new Map();\n    /** @type {any[]} */\n    let newKeys = [];\n    for(let i = 0, len = values.length; i < len; i++) {\n      let key = this.keyFn(values[i], i);\n      expectedMap.set(key, values[i]);\n      newKeys[i] = key;\n    }\n\n    let newHead = 0,\n      newTail = values.length - 1,\n      oldHead = 0,\n      oldTail = oldFrags.length - 1;\n    \n    while(oldHead <= oldTail && newHead <= newTail) {\n      if (oldFrags[oldHead] === null) {\n        oldHead++;\n      } else if (oldFrags[oldTail] === null) {\n        oldTail--;\n      } else if(oldKeys[oldHead] === newKeys[newHead]) {\n        newFrags[newHead] =\n          this.updateFrag(oldFrags[oldHead], newHead, values[newHead]);\n        oldHead++;\n        newHead++;\n      } else if(oldKeys[oldTail] === newKeys[newTail]) {\n        newFrags[newTail] =\n          this.updateFrag(oldFrags[oldTail], newHead, values[newTail]);\n        oldTail--;\n        newTail--;\n      } else if(oldKeys[oldHead] === newKeys[newTail]) {\n        newFrags[newTail] =\n          this.updateFrag(oldFrags[oldHead], newHead, values[newTail]);\n        this.before(oldFrags[oldHead], newFrags[newTail + 1]);\n        oldHead++;\n        newTail--;\n      } else if(oldKeys[oldTail] === newKeys[newHead]) {\n        newFrags[newHead] =\n          this.updateFrag(oldFrags[oldTail], newHead, values[newHead]);\n        this.before(oldFrags[oldTail], oldFrags[oldHead]);\n        oldTail--;\n        newHead++;\n      } else {\n        if(!expectedMap.has(oldKeys[oldHead])) {\n          this.remove(oldFrags[oldHead]);\n          oldHead++;\n        } else if(!expectedMap.has(oldKeys[oldTail])) {\n          this.remove(oldFrags[oldTail]);\n          oldTail--;\n        } else {\n          let value = values[newHead];\n          let frag = this.keyMap.get(this.keyFn(value, newHead));\n          if(frag === undefined) {\n            frag = this.render(newHead, value);\n            this.keyMap.set(this.keyFn(value, newHead), frag);\n          } else {\n            frag = this.updateFrag(frag, newHead, value);\n            // @ts-ignore\n            oldFrags[oldFrags.indexOf(frag)] = null;\n          }\n          newFrags[newHead] = frag;\n          this.append(frag, oldFrags[newHead - 1]);\n          newHead++;\n        }\n      }\n    }\n\n    while(newHead <= newTail) {\n      let frag = this.render(newHead, values[newHead]);\n      this.keyMap.set(this.keyFn(frag.data.item, newHead), frag);\n      this.append(frag, newFrags[newHead - 1]);\n      newFrags[newHead++] = frag;\n      invalid = true;\n    }\n\n    while(oldHead <= oldTail) {\n      let frag = oldFrags[oldHead];\n      this.keyMap.delete(this.keyFn(frag.data.item, oldHead));\n      oldHead++;\n      this.remove(frag);\n      invalid = true;\n    }\n\n    this.keys = newKeys;\n    this.frags = newFrags;\n    return invalid;\n  }\n}","// @ts-check\n\n/**\n * @typedef {import('./sheet').SheetWithValues} SheetWithValues\n * @typedef {Record<string, any>} State \n * @typedef {import('./types').MountedBehavior} MountedBehavior\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n*/\n\n/** @type {Map<string, MountedBehaviorType>} */\nexport let registry = new Map();\n\n/**\n * @typedef {(...args: any[]) => any} CallbackFunction\n * @typedef {(...args: any[]) => Promise<any>} AsyncCallbackFunction\n */\n\n/**\n * \n * @param {Mountpoint} mp \n * @param {CallbackFunction} fn\n * @param {...any[]} args\n * @returns {any}\n */\nfunction scopedCallback(mp, fn, ...args) {\n  let res = fn.call(mp.behavior, ...args);\n  mp.update();\n  return res;\n}\n\n/**\n * \n * @param {Mountpoint} mp \n */\nexport function BehaviorContext(mp) {\n  /** @type {Element | Document | ShadowRoot} */\n  this.element = mp.rootElement;\n  /** @type {() => void} */\n  this.rebind = mp.update.bind(mp);\n  /** @type {Map<string, Map<string, any>>} */\n  this.stores = new Map();\n}\n\nexport class Mountpoint {\n  /**\n   * \n   * @param {HTMLElement | Document | ShadowRoot} rootElement \n   * @param {MountedBehaviorType} Behavior \n   * @param {Map<string, any> | undefined} props\n   */\n  constructor(rootElement, Behavior, props) {\n    /** @type {HTMLElement | Document | ShadowRoot} */\n    this.rootElement = rootElement;\n    /** @type {Map<string, any> | null} */\n    this.props = props || null;\n    /** @type {BehaviorContext} */\n    this.context = new BehaviorContext(this);\n    /** @type {MountedBehavior} */\n    this.behavior = new Behavior(/** @type {never} */(props), this.context);\n    /** @type {SheetWithValues | null} */\n    this.bindings = null;\n    /** @type {WeakMap<CallbackFunction, CallbackFunction>} */\n    this.callbacks = new WeakMap();\n    /** @type {Mountpoint | null} */\n    this.parent = null;\n  }\n  /**\n   * \n   * @param {(...args: any[]) => any} callbackFn \n   * @returns {CallbackFunction}\n   */\n  getCallback(callbackFn) {\n    if(this.callbacks.has(callbackFn))\n      return /** @type {CallbackFunction} */(this.callbacks.get(callbackFn));\n    let listener = scopedCallback.bind(null, this, callbackFn);\n    this.callbacks.set(callbackFn, listener);\n    return listener;\n  }\n  /**\n   * @returns {boolean}\n   */\n  update() {\n    this.bindings = this.behavior.bind(this.props, this.context);\n    return this.bindings.update(this);\n  }\n\n  unmount() {\n    if(this.bindings)\n      this.bindings.unmount(this);\n  }\n}\n\n/**\n * \n * @param {HTMLElement | Document | ShadowRoot} element \n * @param {MountedBehaviorType} behavior\n * @param {Map<string, any>} [props]\n * @returns {Mountpoint}\n */\nexport function mount(element, behavior, props) {\n  let mp = new Mountpoint(element, behavior, props);\n  mp.update();\n  return mp;\n}\n\n/**\n * \n * @param {string} name \n * @param {MountedBehaviorType} behavior\n * @returns {void} \n */\nexport function registerBehavior(name, behavior) {\n  registry.set(name, behavior);\n}","// @ts-check\n\nimport { flags } from './property.js';\nimport { EachInstance } from './each.js';\nimport { Mountpoint } from './mount.js';\nimport { lookup, addItemToScope, removeItemFromScope } from './scope.js';\nimport { storePropName, storeDataSelector, Store } from './store.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./bindings').Bindings} Bindings\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./multi-binding').MultiBinding<string>} KeyedMultiBinding\n * @typedef {import('./multi-binding').MultiBinding<any[]>} ArrayMultiBinding\n * @typedef {import('./multi-binding').MultiBinding<MountedBehaviorType>} BehaviorMultiBinding\n * @typedef {import('./sheet').Root} Root\n * @typedef {import('./types').HostElement} HostElement\n */\n\n/** @type {WeakMap<HostElement, EachInstance>} */\nconst eachInstances = new WeakMap();\n\n/** @type {WeakMap<HostElement, Map<MountedBehaviorType, Mountpoint>>} */\nconst mountPoints = new WeakMap();\n\nconst propsSymbol = Symbol.for('corset.props');\nconst storesSymbol = Symbol.for('corset.stores');\n\n/**\n * \n * @param {HostElement} element \n * @param {Bindings} bindings \n * @param {Root} root\n * @param {Changeset} changeset\n * @returns {boolean}\n */\nfunction render(element, bindings, root, changeset) {\n  let invalid = false;\n  let bflags = bindings.flags;\n\n  if(bflags & flags.storeRoot) {\n    if(!(element instanceof HTMLElement)) {\n      throw new Error('Stores cannot be used on non-HTML elements.');\n    }\n\n    let binding = /** @type {Binding} */(bindings.storeRoot);\n    if(binding.dirty(changeset)) {\n      let oldValue = binding.value;\n      let storeName = binding.update(changeset);\n      if(storeName) {\n        let map = new Store(root);\n        addItemToScope(element, storesSymbol, storeName, Symbol.for(storePropName(storeName)),\n          'corsetStores', map)\n\n        root.mount?.context?.stores.set(storeName, map);\n      } else {\n        removeItemFromScope(element, storesSymbol, oldValue, Symbol.for(storePropName(oldValue)),\n          'corsetStores');\n        root.mount?.context?.stores.delete(oldValue);\n      }\n      invalid = true;\n    }\n  }\n\n  if(bflags & flags.custom) {\n    if(!(element instanceof HTMLElement)) {\n      throw new Error('Custom properties cannot be used on non-HTML elements.');\n    }\n\n    for(let [propertyName, binding] of bindings.custom) {\n      if(binding.dirty(changeset)) {\n        binding.update(changeset);\n        let value = binding.getList();\n        if(value.length) {\n          addItemToScope(element, propsSymbol, propertyName, Symbol.for(propertyName), 'corsetProps', {\n            value,\n            compute: binding.compute\n          });\n        } else {\n          removeItemFromScope(element, propsSymbol, propertyName, Symbol.for(propertyName), 'corsetProps');\n        }\n      }\n    }\n  }\n\n  if(bflags & flags.storeSet) {\n    let binding = /** @type {Binding} */(bindings.storeSet);\n    if(binding.dirty(changeset)) {\n      let args = binding.update(changeset);\n      if(args) {\n        let [storeName, key, value] = args;\n        let map = lookup(element, storeDataSelector(storeName), storePropName(storeName));\n        map?.set(key, value);\n      }\n      invalid = true;\n    }\n  }\n\n  if(bindings.flags & flags.classToggle && 'classList' in element) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.classToggle);\n    for(let [className, toggle] of binding.changes(changeset)) {\n      element.classList.toggle(className, toggle);\n      invalid = true;\n    }\n  }\n\n  if(bflags & flags.each) {\n    let binding = /** @type {ArrayMultiBinding} */(bindings.each);\n    for(let [items, template, key] of binding.values(changeset)) {\n      /** @type {EachInstance | undefined} */\n      let inst;\n      if(eachInstances.has(element)) {\n        inst = /** @type {EachInstance} */(eachInstances.get(element));\n      }\n\n      if(!inst || inst.template !== template) {\n        inst = new EachInstance(element, template, key);\n        eachInstances.set(element, inst);\n      }\n      if(inst.set(items)) invalid = true;\n    }\n  }\n\n  attach: if(bflags & flags.attach) {\n    let binding = /** @type {Binding} */(bindings.attachTemplate);\n    if(binding.dirty(changeset)) {\n      /** @type {HTMLTemplateElement} */\n      let result = binding.update(changeset);\n      if(Array.isArray(result)) result = result[0];\n      if(result === undefined) break attach;\n      let doc = element.ownerDocument || document;\n      let frag = doc.importNode(result.content, true);\n      element.replaceChildren(frag);\n      invalid = true;\n      changeset.flags |= flags.attach;\n    }\n  }\n\n  if(bflags & flags.attr && element instanceof Element) {\n    for(let [key, value, toggle] of /** @type {KeyedMultiBinding} */(bindings.attr).changes(changeset)) {\n      if(toggle)\n        element.setAttribute(key, value);\n      else\n        element.removeAttribute(key);\n      invalid = true;\n    }\n  }\n\n  if(bflags & flags.data) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.data);\n    for(let [prop, value] of binding.changes(changeset)) {\n      if(value === undefined)\n        delete /** @type {HTMLElement} */\n        (element).dataset[prop];\n      else\n        /** @type {HTMLElement} */\n        (element).dataset[prop] = value;\n\n      invalid = true;\n    }\n  }\n\n  text: if(bflags & flags.text) {\n    let binding = /** @type {Binding} */(bindings.text);\n    if(binding.dirty(changeset)) {\n      let values = binding.update(changeset);\n      if(changeset.flags & flags.attach) break text;\n      if(Array.isArray(values)) values = values.join('');\n      element.textContent = values;\n    }\n  }\n\n  if(bflags & flags.prop) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.prop);\n    for(let [key, value] of binding.changes(changeset)) {\n      /** @type {any} */(element)[key] = value;\n    }\n  }\n\n  if(bflags & flags.behavior) {\n    let binding = /** @type {BehaviorMultiBinding} */(bindings.behavior);\n    for(let [Behavior, props, OldBehavior] of binding.changes(changeset)) {\n      let hasOldValue = OldBehavior !== undefined;\n      let sameBehavior = hasOldValue && OldBehavior === Behavior;\n\n      /** @type {Map<MountedBehaviorType, Mountpoint>} */\n      let map;\n      if(mountPoints.has(element))\n        map = /** @type {Map<MountedBehaviorType, Mountpoint>} */(mountPoints.get(element));\n      else {\n        map = new Map();\n        mountPoints.set(element, map);\n      }\n\n      if(hasOldValue || sameBehavior) {\n        let mp = /** @type {Mountpoint} */(map.get(OldBehavior));\n        if(sameBehavior) {\n          if(mp.update()) invalid = true;\n        }\n        else mp.unmount();\n      }\n      if(!sameBehavior && Behavior !== null) {\n        let mountpoint = new Mountpoint(/** @type {HTMLElement} */(element), Behavior, props);\n        mountpoint.parent = root.mount;\n        if(mountpoint.update()) invalid = true;\n        map.set(Behavior, mountpoint);\n      }\n    }\n  }\n\n  // Events last, does not affect the cascade.\n  if(bflags & flags.event) {\n    let binding = /** @type {KeyedMultiBinding} */(bindings.event);\n    for(let [eventName, listener, capture, once, passive, signal, _oldEventName, oldListener, oldCapture] of binding.changes(changeset)) {\n      if(oldListener !== undefined)\n        element.removeEventListener(eventName, root.getCallback(oldListener), oldCapture);\n      if(listener)\n        element.addEventListener(eventName, root.getCallback(listener), {\n          capture,\n          once,\n          passive,\n          signal\n        });\n    }\n  }\n\n  return invalid;\n}\n\n/**\n * @param {Map<Element | ShadowRoot | Document, Bindings>} allBindings\n * @param {Root} root\n * @param {Changeset} changeset\n * @returns {boolean}\n */\nexport function renderRoot(allBindings, root, changeset) {\n  let invalid = false;\n  for(let [element, bindings] of allBindings) {\n    if(render(element, bindings, root, changeset))\n      invalid = true;\n  }\n  return invalid;\n}\n\n/**\n * \n * @param {HostElement} element \n * @param {Bindings} bindings \n * @param {Root} root\n */\nfunction unmount(element, bindings, root) {\n  let bflags = bindings.flags;\n  if(bflags & flags.behavior) {\n    let binding = /** @type {BehaviorMultiBinding} */(bindings.behavior);\n    let map = /** @type {Map<MountedBehaviorType, Mountpoint>} */(mountPoints.get(element));\n    for(let [OldBehavior] of binding.current()) {\n      map.get(OldBehavior)?.unmount();\n    }\n    // TODO allow multiple\n    ///** @type {Mountpoint} */(mountPoints.get(element)).unmount();\n  }\n\n  if(bflags & flags.event) {\n    let eventBinding = /** @type {KeyedMultiBinding} */(bindings.event);\n    for(let [_key, eventName, listener] of eventBinding.current()) {\n      element.removeEventListener(eventName, root.getCallback(listener));\n    }\n  }\n}\n\n/**\n * @param {Map<HostElement, Bindings>} allBindings\n * @param {Root} root\n */\nexport function unmountRoot(allBindings, root) {\n  for(let [element, bindings] of allBindings) {\n    unmount(element, bindings, root);\n  }\n}","// @ts-check\n\nexport class Changeset {\n  /**\n   * \n   * @param {any[]} values \n   */\n  constructor(values) {\n    /** @type {any[]} */\n    this.values = values;\n    /** @type {boolean} */\n    this.selectors = true;\n    /** @type {number} */\n    this.flags = 0;\n  }\n}","// @ts-check\nimport { Bindings } from './bindings.js';\nimport { renderRoot, unmountRoot } from './render.js';\nimport { Changeset } from './changeset.js';\nimport { Mountpoint } from './mount.js';\n\n/**\n * @typedef {import('./types').HostElement} HostElement\n * @typedef {import('./types').RootElement} RootElement\n */\n\n/**\n * \n * @param {Function} a \n * @returns {Function}\n */\nconst identity = (a) => a;\n\n/**\n * @typedef {import('./rule').Rule} Rule\n */\n\nexport class Root {\n  /**\n   * @param {RootElement | Mountpoint} rootElement \n   * @param {BindingSheet} sheet \n   */\n  constructor(rootElement, sheet) {\n    /** @type {Mountpoint | null} */\n    this.mount = (rootElement instanceof Mountpoint) ? rootElement : null;\n    /** @type {RootElement} */\n    this.rootElement = this.mount ? this.mount.rootElement :\n      /** @type {HTMLElement} */(rootElement);\n    /** @type {Rule[]} */\n    this.rules = sheet.rules;\n    /** @type {Map<HostElement, Bindings>} */\n    this.bindingMap = new Map();\n    /** @type {(a: () => any) => any} */\n    this.getCallback = this.mount ? this.mount.getCallback.bind(this.mount) : identity;\n    /** @type {any[]} */\n    this.values = /** @type {any[]} */(/** @type {unknown} */(null));\n    /** @type {number} */\n    this.queue = 0;\n  }\n  /**\n   * @param {any[]} values\n   * @returns {boolean}\n   */\n  update(values = this.values) {\n    this.values = values;\n    this.queue++;\n    if(this.queue > 1) return false;\n    let invalid = true;\n    let changed = false;\n    while(invalid) {\n      let changeset = new Changeset(values);\n      this.collect();\n      invalid = renderRoot(this.bindingMap, this, changeset);\n      if(invalid) changed = true;\n    }\n    if(changed) {\n      this.mount?.parent?.update();\n    }\n    this.queue = 0;\n    return changed;\n  }\n  /**\n   * Collect all of the bindings\n   */\n  collect() {\n    let rootElement = this.rootElement;\n    for(let rule of this.rules) {\n      for(let el of rule.querySelectorAll(rootElement)) {\n        /** @type {Bindings} */\n        let bindings;\n        if(this.bindingMap.has(el)) {\n          bindings = /** @type {Bindings} */(this.bindingMap.get(el));\n        } else {\n          bindings = new Bindings(this, el);\n          this.bindingMap.set(el, bindings);\n        }\n        for(let declaration of rule.declarations) {\n          bindings.add(declaration);\n        }\n      }\n    }\n  }\n  unmount() {\n    unmountRoot(this.bindingMap, this);\n  }\n}\n\nexport class BindingSheet {\n  constructor() {\n    /** @type {Rule[]} */\n    this.rules = [];\n  }\n  /**\n   * Add a rule to this sheet\n   * @param {Rule} rule \n   */\n  addRule(rule) {\n    this.rules.push(rule);\n  }\n}\n\nexport class SheetWithValues {\n  /**\n   * @param {BindingSheet} sheet\n   * @param {any[]} values\n   */\n  constructor(sheet, values) {\n    /** @type {WeakMap<Element | Mountpoint, Root>} */\n    this.roots = new WeakMap();\n    this.sheet = sheet;\n    this.values = values;\n  }\n\n  /**\n   * @param {HTMLElement | Mountpoint} rootElement\n   * @returns {boolean}\n   */\n  update(rootElement) {\n    /** @type {Root} */\n    let root;\n    if(this.roots.has(rootElement)) {\n      root = /** @type {Root} */(this.roots.get(rootElement));\n    } else {\n      root = new Root(rootElement, this.sheet);\n      this.roots.set(rootElement, root);\n    }\n    return root.update(this.values);\n  }\n  /**\n   * \n   * @param {Element | Mountpoint} rootElement \n   */\n  unmount(rootElement) {\n    if(this.roots.has(rootElement)) {\n      let root = /** @type {Root} */(this.roots.get(rootElement));\n      root.unmount();\n    }\n  }\n}","// @ts-check\n\nimport { anyValue, NO_VALUE } from './value.js';\nimport { createValueTemplate } from './template.js';\nimport { ComputedValue } from './compute.js';\nimport { registry as behaviorRegistry } from './mount.js';\nimport { lookup } from './scope.js';\nimport { storeDataSelector, storePropName, getKeySymbol } from './store.js';\n\n/**\n * @typedef {import('./binding').Binding} Binding\n * @typedef {import('./changeset').Changeset} Changeset\n * @typedef {import('./fn').ICorsetFunction} ICorsetFunction\n * @typedef {import('./fn').ICorsetFunctionClass} ICorsetFunctionClass\n * @typedef {import('./fn').FunctionContext} FunctionContext\n * @typedef {import('./types').MountedBehaviorType} MountedBehaviorType\n */\n\n/**\n * @typedef {Object} FunctionRegistry - Some explanation of what this is.\n * @property {Map<string, ICorsetFunctionClass>} fns\n */\n\nconst RegistryBase = {};\n\n/**\n * @returns {FunctionRegistry}\n */\nfunction createRegistry() {\n  return Object.create(RegistryBase, {\n    fns: {\n      enumerable: true,\n      value: new Map()\n    }\n  });\n}\n\nexport const registry = createRegistry();\nexport const localsRegistry = createRegistry();\n\n/**\n * \n * @this {FunctionRegistry}\n * @param {string} name \n * @param {ICorsetFunctionClass} ctr \n */\nfunction registerFunction(name, ctr) {\n  this.fns.set(name, ctr);\n}\n\n/**\n * \n * @this {FunctionRegistry | void}\n * @param {string} name \n * @param {ICorsetFunctionClass} ctr \n */\nexport function registerCustomFunction(name, ctr) {\n  if(!name.startsWith('--')) {\n    throw new Error(`Custom functions must start with --`);\n  }\n  let reg = this;\n  if(!reg || !RegistryBase.isPrototypeOf(reg)) {\n    reg = registry;\n  }\n  registerFunction.call(reg, name, ctr);\n}\n\nregisterFunction.call(registry, 'get', class {\n  constructor() {\n    this.value = NO_VALUE;\n  }\n  /**\n   *\n   * @param {[{[key: string | symbol]: any}, CallbackOrProp]} args\n   * @returns\n   */\n  check([value, callbackOrProp]) {\n    if(typeof value === 'object') {\n      if(typeof callbackOrProp !== 'function') {\n        let newValue = getKeySymbol in value ?\n          value[getKeySymbol](callbackOrProp) :\n          value[callbackOrProp];\n        if(newValue !== this.value) {\n          this.value = newValue;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * \n   * @typedef {((o: {}) => any) | string} CallbackOrProp\n   * \n   * @param {[{[key: string | symbol]: any}, CallbackOrProp]} args\n   * @returns {any}\n   */\n  call([value, callbackOrProp]) {\n    if(typeof callbackOrProp === 'function') {\n      return callbackOrProp(value);\n    } else if(getKeySymbol in value) {\n      return value[getKeySymbol](callbackOrProp);\n    } else {\n      return value[callbackOrProp];\n    }\n  }\n});\n\nregisterFunction.call(registry, 'select', class {\n  /**\n   * \n   * @param {[string]} param0\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} ctx \n   */\n  call([selector], _props, { rootElement }) {\n    return rootElement.querySelector(selector);\n  }\n});\n\nclass ScopeLookupFunction {\n  /**\n   * Look up a value within the DOM scope\n   * @param {string} dataName\n   * @param {string} propName\n   */\n   constructor(dataName, propName) {\n    /** @type {string} */\n    this.dataSelector = `[data-corset-scope~=${dataName}]`;\n    /** @type {string} */\n    this.propName = propName;\n    /** @type {any} */\n    this.value = NO_VALUE;\n  }\n  /**\n   * \n   * @param {any[]} param0\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  check([], _props, { element }, changeset) {\n    let check = false;\n    if(changeset.selectors) check = true;\n    if(check) {\n      let value = lookup(element, this.dataSelector, this.propName);\n      if(value !== this.value) {\n        this.value = value;\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * \n   * @returns {any}\n   */\n  call() {\n    return this.value;\n  }\n}\n\nregisterFunction.call(registry, 'item', class extends ScopeLookupFunction {\n  constructor() {\n    super('item', 'corset.item');\n  }\n});\n\nregisterFunction.call(registry, 'index', class extends ScopeLookupFunction {\n  constructor() {\n    super('index', 'corset.index');\n  }\n});\n\nregisterFunction.call(registry, 'store-get', class {\n  constructor() {\n    /** @type {any} */\n    this.value = undefined;\n  }\n  /**\n   * \n   * @param {[string, string]} _args\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  check([storeName, key], _props, { element }, changeset) {\n    let check = changeset.selectors;\n    if(check) {\n      /** @type {Map<string, any> | undefined} */\n      let map = lookup(element, storeDataSelector(storeName), storePropName(storeName));\n      if(map?.get(key) !== this.value) {\n        this.value = map?.get(key);\n        return true;\n      }\n    }\n    return false;\n  }\n  call() {\n    return this.value;\n  }\n});\n\nregisterFunction.call(registry, 'store', class {\n  constructor() {\n    /** @type {Map<any, any> | undefined} */\n    this.map = undefined;\n  }\n  /**\n   * \n   * @param {[string]} _args\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n   check([storeName], _props, { element }, changeset) {\n    let check = changeset.selectors;\n    if(check) {\n      /** @type {Map<any, any> | undefined} */\n      let map = lookup(element, storeDataSelector(storeName), storePropName(storeName));\n      if(map !== this.map) {\n        this.map = map;\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @returns {Map<any, any> | undefined}\n   */\n  call() {\n    return this.map;\n  }\n});\n\nregisterFunction.call(registry, 'bind', class {\n  /**\n   * \n   * @param {[Function, ...any[]]} param0\n   * @returns \n   */\n  call([fn, ...boundArgs]) {\n    /**\n     * @this {MountedBehaviorType | Element}\n     * @param {...any[]} callArgs\n     * @returns {(...args: any[]) => any}\n     */\n    function boundFn(...callArgs) {\n      return fn.call(this, ...boundArgs, ...callArgs);\n    }\n    Object.defineProperty(boundFn, 'name', {\n      value: 'bound ' + fn.name\n    });\n    return boundFn;\n  }\n});\n\nregisterFunction.call(registry, 'data', class {\n  /**\n   * \n   * @param {[string]} param0 \n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} param1\n   */\n  call([prop], _props, { element }) {\n    if(!(element instanceof HTMLElement))\n      throw new Error(`data() only works on HTMLElements.`);\n    return /** @type {HTMLElement} */(element).dataset[prop];\n  }\n});\n\n/**\n * @typedef {Readonly<[MountedBehaviorType, Map<string, any> | null]>} MountValue\n */\n\nregisterFunction.call(registry, 'mount', class {\n  constructor() {\n    /** @type {ComputedValue | null} */\n    this.compute = null;\n    /** @type {MountedBehaviorType | null} */\n    this.Behavior = null;\n    /** @type {MountValue | null} */\n    this.value = null;\n  }\n  /**\n   *\n   * @param {[MountedBehaviorType | string]} param0\n   * @param {Map<string, any>} _props\n   * @param {FunctionContext} context\n   * @param {Changeset} changeset\n   * @returns {boolean}\n   */\n  check([Ctr], _props, context, changeset) {\n    /** @type {MountedBehaviorType} */\n    let Behavior = /** @type {MountedBehaviorType} */(Ctr);\n    if(typeof Ctr === 'string') {\n      let name = Ctr;\n      if(!behaviorRegistry.has(name))\n        throw new Error(`Unregistered behavior ${name}`);\n      Behavior = /** @type {MountedBehaviorType} */(behaviorRegistry.get(name));\n    }\n\n    if(Behavior !== this.Behavior) {\n      let ValueType = anyValue(Behavior);\n      ValueType.inputProperties = Behavior.inputProperties;\n      let template = createValueTemplate(ValueType);\n      this.Behavior = Behavior;\n      this.compute = new ComputedValue(\n        template,\n        // A FunctionContext's prototype is actually a Binding at runtime.\n        // If this ever changes, the following will be a wrong cast.\n        /** @type {Binding} */(Object.getPrototypeOf(context))\n      );\n      this.compute.check(changeset);\n      this.value = /** @type {MountValue} */\n        (Object.freeze([Behavior, this.compute.inputProps]));\n      return true;\n    } else if(this.compute) {\n      let dirty = this.compute.dirty(changeset);\n      this.compute.check(changeset);\n      return dirty;\n    }\n    return false;\n  }\n  /**\n   *\n   * @param {[]} param0\n   */\n  call([]) {\n    return this.value;\n  }\n});\n\n/**\n * \n * @param {string} propName \n * @returns {ICorsetFunctionClass}\n */\nexport function createLocalsScopeFunction(propName) {\n  /** @type {ICorsetFunctionClass} */\n  class ScopeLookupFunction {\n    static inputProperties = [propName];\n    /**\n     * \n     * @param {any[]} args \n     * @param {Map<typeof propName, any>} props\n     * @param {FunctionContext} context \n     */\n    call(args, props, context) {\n      /** @type {((...args: any[]) => any) | undefined} */\n      let fn = props.get(propName);\n      if(typeof fn !== 'function') {\n        throw new Error(`Unable to find the custom function ${propName}`);\n      }\n      return fn.apply(context, args);\n    }\n  }\n\n  registerCustomFunction.call(localsRegistry, propName, ScopeLookupFunction);\n  return ScopeLookupFunction;\n}","// @ts-check\n\n/**\n * @typedef {import('./parser').RawStringTemplate} RawStringTemplate\n */\n\n import {\n  heap8,\n  heap32, mem32,\n  parse, next,\n  readNumberOfValues,\n  readFirstValuePointer,\n  readProperty,\n  readString\n} from './parser.js';\nimport { Declaration } from './declaration.js';\nimport { Rule } from './rule.js';\nimport { BindingSheet, SheetWithValues } from './sheet.js';\nimport {\n  anyValue,\n  CommaSeparatedListValue,\n  functionValue,\n  InsertionValue,\n  PlaceholderValue,\n  SpaceSeparatedListValue,\n} from './value.js';\nimport {\n  registry as fnRegistry,\n  localsRegistry as fnLocalsRegistry,\n  createLocalsScopeFunction\n} from './function.js';\nimport { properties, features } from './property.js';\nimport { createValueTemplate } from './template.js';\nimport { Name, KEYWORD_REVERT_SHEET, KEYWORD_ALL } from './constants.js';\n\n/**\n * @typedef {import('./property').PropertyDefinition} PropertyDefinition\n * @typedef {import('./types').ValueType} ValueType\n * @typedef {import('./types').Value} Value\n * @typedef {import('./template').ValueTemplate} ValueTemplate\n * @typedef {import('./function').ICorsetFunctionClass} ICorsetFunctionClass\n */\n\nlet keywordMap = new Map([\n  [3, KEYWORD_REVERT_SHEET],\n  [4, KEYWORD_ALL]\n]);\n\n/**\n * Gets the value at the pointer location.\n * @param {Number} ptr\n * @returns {ValueTemplate}\n */\nfunction getValue(ptr) {\n  let ptr32 = ptr >> 2;\n  let ptrv32 = ptr32 + 3;\n  \n  let valueType = mem32[ptr32];\n  switch(valueType) {\n    case 1: {\n      return createValueTemplate(InsertionValue, [\n        createValueTemplate(anyValue(mem32[ptrv32]))\n      ]);\n    }\n    case 2:\n    case 3: {\n      return createValueTemplate(\n        anyValue(readString(mem32[ptrv32], mem32[ptrv32 + 1]))\n      );\n    }\n    case 4: {\n      let fnName = readString(mem32[ptrv32], mem32[ptrv32 + 1]);\n      /** @type {ValueType} */\n      let Value;\n      switch(true) {\n        case fnName === 'var': Value = PlaceholderValue; break;\n        case fnRegistry.fns.has(fnName): {\n          let CorsetFunction = /** @type {ICorsetFunctionClass} */(fnRegistry.fns.get(fnName));\n          Value = functionValue(CorsetFunction);\n          break;\n        }\n        case fnLocalsRegistry.fns.has(fnName): {\n          let CorsetFunction = /** @type {ICorsetFunctionClass} */(fnLocalsRegistry.fns.get(fnName));\n          Value = functionValue(CorsetFunction);\n          break;\n        }\n        case fnName.startsWith('--'): {\n          let CorsetFunction = createLocalsScopeFunction(fnName);\n          Value = functionValue(CorsetFunction);\n          break;\n        }\n        default: throw new Error(`Unknown function ${fnName}`);\n      }\n\n      let args = [];\n      let vptr = mem32[ptrv32 + 3];\n      while(vptr) {\n        args.push(getValue(vptr));\n        vptr = mem32[(vptr >> 2) + 1];\n      }\n\n      return createValueTemplate(Value, args);\n    }\n    case 6: {\n      return createValueTemplate(anyValue(Boolean(mem32[ptrv32])));\n    }\n    case 7: {\n      return createValueTemplate(anyValue(Name.for(readString(mem32[ptrv32], mem32[ptrv32 + 1]))))\n    }\n    case 8: {\n      return createValueTemplate(anyValue(keywordMap.get(mem32[ptrv32])));\n    }\n    default: {\n      throw new Error(`Unknown value type [${valueType}]`);\n    }\n  }\n}\n\n/**\n * \n * @param {RawStringTemplate} strings \n * @param {any[]} values \n * @returns \n */\nfunction compile(strings, values) {\n  let sheet = new BindingSheet();\n  let sourceOrder = 0;\n  let rule;\n  parse(strings, values);\n  while(next()) {\n    switch(heap8[0]) {\n      case 1: {\n        rule = new Rule(readString(heap32[1], heap32[2]));\n        sheet.addRule(rule);\n        break;\n      }\n      case 2: {\n        let propName = readProperty();\n\n        let ptr = readFirstValuePointer();\n        let num = readNumberOfValues();\n\n        /** @type {PropertyDefinition} */\n        let defn = properties[propName];\n\n        /** @type {ValueTemplate[]} */\n        let args = [], _args = args;\n        while(ptr) {\n          let valueType = mem32[ptr >> 2];\n          switch(valueType) {\n            case 5: {\n              if(args === _args) {\n                args = [];\n              }\n              args.push(createValueTemplate(SpaceSeparatedListValue, _args));\n              _args = [];\n              break;\n            }\n            default: {\n              _args.push(getValue(ptr));\n              break;\n            }\n          }\n          ptr = mem32[(ptr >> 2) + 1];\n        }\n        let commaSeparated = args !== _args;\n        // Multis are coerced to comma separated even if they had no commas.\n        // Ideally this would happen in the parser.\n        if(defn?.feat & features.multi && !commaSeparated) {\n          args = [];\n        }\n        if(commaSeparated || ((defn?.feat & features.multi))) {\n          args.push(createValueTemplate(SpaceSeparatedListValue, _args));\n        }\n\n        //let declaration = new Declaration(/** @type {Rule} */(rule), propName, sourceOrder++);\n        /** @type {ValueTemplate} */\n        let template;\n        switch(true) {\n          case !!(defn?.feat & features.multi): {\n            template = createValueTemplate(CommaSeparatedListValue, args);\n            break;\n          }\n          case !!(defn?.feat & features.longhand) || num > 1: {\n            let Value = commaSeparated ? CommaSeparatedListValue : SpaceSeparatedListValue;\n            template = createValueTemplate(Value, args);\n            break;\n          }\n          default: {\n            template = args[0];\n            break;\n          }\n        }\n\n        let declaration = new Declaration(/** @type {Rule} */(rule), propName, sourceOrder++, template);\n\n        declaration.init();\n        /** @type {Rule} */(rule).addDeclaration(declaration);\n\n        break;\n      }\n      // TODO remove in build\n      case 4: {\n        let code = heap32[1];\n        switch(code) {\n          case 1:\n          case 2: {\n            let charCode = heap32[2];\n            switch(charCode) {\n              // '\n              case 39: {\n                throw new SyntaxError(\"Saw the a single quote character ('). Use double quotes (\\\") for strings.\")\n              }\n              default: {\n                throw new SyntaxError(`Unexpected token \"${String.fromCharCode(charCode)}\" found. Error code ${code}.`);\n              }\n            }\n            \n          }\n          default: {\n            throw new Error(`Unknown Parse error occurred. Error code [${code}]`);\n          }\n        }\n      }\n    }\n  }\n  return sheet;\n}\n\nconst cache = new WeakMap();\n\n/**\n * \n * @param {RawStringTemplate} strings \n * @param {any[]} values \n * @returns {SheetWithValues}\n */\nfunction memoizeCompile(strings, values) {\n  if(cache.has(strings)) {\n    return cache.get(strings);\n  }\n  let bindingSheet = compile(strings, values);\n  let sheet = new SheetWithValues(bindingSheet, values);\n  cache.set(strings, sheet);\n  return sheet;\n}\n\n/**\n * The main DSL\n * @param {RawStringTemplate} strings \n * @param  {...any} values \n * @returns {SheetWithValues}\n */\nexport function sheet(strings, ...values) {\n  let sheet = memoizeCompile(strings, values);\n  sheet.values = values;\n  return sheet;\n}"],"names":["exports","WebAssembly","instantiateStreaming","fetch","URL","import","meta","url","toString","instance","$get_tag","get_tag","$memory","memory","$parse","parse","$reset","reset","mem8","Uint8Array","buffer","mem32","Uint32Array","heap8","heap32","data8","enc","TextEncoder","dec","TextDecoder","readFromBuffer","start","end","decode","slice","len","readString","properties","flag","feat","prop","read","el","tmpl","ownerDocument","document","createElement","content","append","Array","from","childNodes","attr","features","longhand","defaults","shorthand","index","default","key","getAttribute","hasAttribute","classList","contains","data","Error","dataset","each","event","undefined","behavior","text","textContent","Declaration","constructor","rule","propertyName","sourceOrder","template","this","keyTemplate","flags","init","defn","multi","label","rootSelect","querySelect","querySelectorAll","selector","Rule","declarations","specificity","addDeclaration","declaration","push","lookup","element","dataSelector","propName","matches","Symbol","for","closest","addItemToScope","listSym","keySym","dataProp","value","e","list","Set","add","str","join","removeItemFromScope","delete","size","getKeySymbol","Store","Map","root","updateMount","super","Object","_classPrivateFieldLooseBase","mount","update","bind","Function","prototype","get","set","k","v","storePropName","storeName","storeDataSelector","NO_VALUE","anyValue","InsertionValue","current","check","_binding","_props","values","SpaceSeparatedListValue","CommaSeparatedListValue","PlaceholderValue","compute","args","binding","changeset","selectors","dirty","scope","length","functionValue","CorsetFunction","callValue","call","FunctionValue","context","create","createStore","fn","props","inputProperties","checkValue","ComputedValue","WeakMap","argDeps","inputDeps","inputProps","raw","Value","dep","deps","hydrate","listValue","calculate","has","method","isArray","compare","d1","d2","Binding","rootElement","computedValues","initial","addTemplate","sorted","item","comparator","low","high","mid","splice","binaryInsert","getList","hasValue","walk","i","ConstantMethods","map","is","isPrototypeOf","base","createConstant","ConstantBase","name","enumerable","writable","configurable","assign","Name","Keyword","KEYWORD_REVERT_SHEET","KEYWORD_ALL","SparseArray","fill","numberOfValues","empty","full","createValueTemplate","MultiBinding","numberOfValuesWithKey","active","oldValues","declFlags","unset","valueMap","getValueList","numOfValues","valueList","dirtyKeys","loop","computedValue","idx","val","isName","Behavior","allValues","keyed","propValue","hasLabel","initialValues","valuesWithKey","out","concat","changes","type","freeze","keyIsName","d","SimpleBinding","Bindings","seen","WeakSet","attachTemplate","classToggle","storeRoot","storeSet","custom","multiDef","startsWith","bindingProp","eachSymbol","itemSymbol","indexSymbol","EachInstance","host","keyMap","keyFn","keyKeyed","keyNonKeyed","doc","createComment","after","frags","keys","updateValues","setData","frag","nodes","render","importNode","_","refrag","firstChild","ref","before","remove","clear","nextSibling","startNode","next","node","updateFrag","invalid","oldFrags","newFrags","oldKeys","expectedMap","newKeys","newHead","newTail","oldHead","oldTail","indexOf","registry","scopedCallback","mp","res","BehaviorContext","rebind","stores","Mountpoint","bindings","callbacks","parent","getCallback","callbackFn","listener","unmount","registerBehavior","eachInstances","mountPoints","propsSymbol","storesSymbol","bflags","HTMLElement","oldValue","className","toggle","items","inst","attach","result","replaceChildren","Element","setAttribute","removeAttribute","OldBehavior","hasOldValue","sameBehavior","mountpoint","eventName","capture","once","passive","signal","_oldEventName","oldListener","oldCapture","removeEventListener","addEventListener","renderRoot","allBindings","eventBinding","_key","Changeset","identity","a","Root","sheet","rules","bindingMap","queue","changed","collect","unmountRoot","BindingSheet","addRule","SheetWithValues","roots","RegistryBase","createRegistry","fns","localsRegistry","registerFunction","ctr","registerCustomFunction","reg","callbackOrProp","newValue","querySelector","ScopeLookupFunction","dataName","boundArgs","boundFn","callArgs","defineProperty","Ctr","behaviorRegistry","ValueType","getPrototypeOf","keywordMap","getValue","ptr","ptr32","ptrv32","valueType","fnName","fnRegistry","fnLocalsRegistry","apply","createLocalsScopeFunction","vptr","Boolean","cache","strings","bindingSheet","source","holes","String","bytes","encode","byteLength","dataPtr","subarray","tagPtr","num","_args","commaSeparated","code","charCode","SyntaxError","fromCharCode","compile","memoizeCompile"],"mappings":"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"}